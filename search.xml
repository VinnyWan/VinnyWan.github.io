<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache RocketMQ 消息队列部署</title>
    <url>/post/bc2707ce.html</url>
    <content><![CDATA[<h1 id="Apache-RocketMQ-消息队列部署"><a href="#Apache-RocketMQ-消息队列部署" class="headerlink" title="Apache RocketMQ 消息队列部署"></a>Apache RocketMQ 消息队列部署</h1><p>Apache RocketMQ是一个分布式、队列模型的消息中间件，具有低延迟、高性能和高可靠、万亿级容量和灵活的可扩展性。核心组件由四部分组成：Name Servers，Brokers，Producer 和 Consumer；它们中的每一个都可以水平扩展，而没有单一的故障节点。<br>详细组件介绍请参考github: <a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md</a><br>对应的rockermq的特性介绍: <a href="https://github.com/apache/rocketmq/blob/master/docs/cn/features.md">https://github.com/apache/rocketmq/blob/master/docs/cn/features.md</a></p>
<a id="more"></a>
<ul>
<li>NameServer：是一个几乎无状态的节点，可集群部署，节点之间无任何信息同步</li>
<li>Broker：部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slaver，但是一个Slaver只能对应一个Master，Master与Slaver的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slaver。Master可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有的NameServer</li>
</ul>
<h1 id="Apache-RocketMQ安装部署"><a href="#Apache-RocketMQ安装部署" class="headerlink" title="Apache RocketMQ安装部署"></a>Apache RocketMQ安装部署</h1><p>打开对应的版本地址, 如下的是github的版本地址<br><a href="https://github.com/apache/rocketmq/releases">https://github.com/apache/rocketmq/releases</a><br>如下是本次部署的架构规划图,本次部署选择的版本是<code>4.7.1</code>,选择长期支持版本<br><img src="/images/rockermq/rockermqjiagou.jpg" alt="rockermqjiagou"></p>
<h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><p>RocketMQ有三种部署方式：</p>
<ul>
<li>2m-2s-async。多主多从异步复制</li>
<li>2m-2s-sync。多主多从同步复制</li>
<li>2m-noslave。多主无从</li>
</ul>
<p>生产broker-master和broker-slaver尽量分开.<br>本文介绍2m-2s-async多主多从异步复制集群安装方式，集群包含三台节点 配置均为2c4g,各节点Broker分布情况：<br>|  节点  |IP   | 主服务    |从服务        |<br>|  —-  | —-| —-      |—-        |<br>| node1  | 192.168.1.10| broker-a |broker-b-s    |<br>| node2  | 192.168.1.11| broker-b |broker-c-s    |<br>| node3  | 192.168.1.12| broker-c |broker-a-s    |</p>
<h2 id="修改启动脚本内存参数"><a href="#修改启动脚本内存参数" class="headerlink" title="修改启动脚本内存参数"></a>修改启动脚本内存参数</h2><p>每个节点均需要执行如下操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;rocketmq&#x2F;archive&#x2F;rocketmq-all-4.7.1.tar.gz</span><br><span class="line">tar xf rocketmq-all-4.7.1.tar.gz</span><br><span class="line">ln -sv rocketmq-all-4.7.1-bin-release rocketmq</span><br><span class="line">vim &#x2F;opt&#x2F;rocketmq&#x2F;bin&#x2F;runbroker.sh</span><br><span class="line"># 修改 根据实际所需进行修改, 一般是内存的50%, 最多不能超过75%</span><br><span class="line">#JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g&quot;</span><br><span class="line">JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;256m&quot;</span><br><span class="line"># 注释  debug模式</span><br><span class="line">#JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -Xdebug -Xrunjdwp:transport&#x3D;dt_socket,address&#x3D;9555,server&#x3D;y,suspend&#x3D;n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim &#x2F;opt&#x2F;rocketmq&#x2F;bin&#x2F;runserver.sh</span><br><span class="line"># 注释</span><br><span class="line">#JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -Xdebug -Xrunjdwp:transport&#x3D;dt_socket,address&#x3D;9555,server&#x3D;y,suspend&#x3D;n&quot;</span><br><span class="line">#JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;320m&quot;</span><br><span class="line">JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;256m&quot;</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="192-168-1-10配置文件"><a href="#192-168-1-10配置文件" class="headerlink" title="192.168.1.10配置文件"></a>192.168.1.10配置文件</h3><p>broker.conf配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat broker.conf</span><br><span class="line">brokerClusterName &#x3D; DefaultCluster</span><br><span class="line">brokerName &#x3D; broker-a</span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line">fileReservedTime &#x3D; 48</span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br></pre></td></tr></table></figure>
<p>2m-2s-async/broker-a.properties 配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 2m-2s-async&#x2F;broker-a.properties </span><br><span class="line">#集群名</span><br><span class="line">brokerClusterName&#x3D;Data-Cluster</span><br><span class="line">#broker名字</span><br><span class="line">brokerName&#x3D;broker-a</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId&#x3D;0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr&#x3D;18.16.200.248:9876;18.16.200.230:9876;18.16.200.239:9876</span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums&#x3D;3</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable&#x3D;true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup&#x3D;true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort&#x3D;10911</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">#fileReservedTime&#x3D;3600</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;300000</span><br><span class="line">#destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line">#redeleteHangedFileInterval&#x3D;120000</span><br><span class="line">#文件磁盘最大利用率</span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store-a</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;commitlog-a</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;consumequeue-a</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line">#flushCommitLogLeastPages&#x3D;4</span><br><span class="line">#flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line">#flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line">#flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole&#x3D;ASYNC_MASTER</span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br></pre></td></tr></table></figure>
<p>2m-2s-async/broker-b-s.properties  配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 2m-2s-async&#x2F;broker-b-s.properties </span><br><span class="line">#集群名</span><br><span class="line">brokerClusterName&#x3D;Data-Cluster</span><br><span class="line">#broker名字</span><br><span class="line">brokerName&#x3D;broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId&#x3D;1</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr&#x3D;18.16.200.248:9876;18.16.200.230:9876;18.16.200.239:9876</span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums&#x3D;3</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">#autoCreateTopicEnable&#x3D;ture</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">#autoCreateSubscriptionGroup&#x3D;ture</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort&#x3D;20912</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">#fileReservedTime&#x3D;3600</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;300000</span><br><span class="line">#destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line">#redeleteHangedFileInterval&#x3D;120000</span><br><span class="line">#磁盘最大利用率</span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store-b-s</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;commitlog-b-s</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;consumequeue-b-s</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line">#flushCommitLogLeastPages&#x3D;4</span><br><span class="line">#flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line">#flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line">#flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">#brokerRole&#x3D;ASYNC_MASTER</span><br><span class="line">brokerRole&#x3D;SLAVE</span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="192-168-1-11配置文件"><a href="#192-168-1-11配置文件" class="headerlink" title="192.168.1.11配置文件"></a>192.168.1.11配置文件</h3><p>broker.conf配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat broker.conf</span><br><span class="line">brokerClusterName &#x3D; DefaultCluster</span><br><span class="line">brokerName &#x3D; broker-b</span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line">fileReservedTime &#x3D; 48</span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br></pre></td></tr></table></figure>
<p>2m-2s-async/broker-b.properties   配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 2m-2s-async&#x2F;broker-b.properties </span><br><span class="line">#集群名</span><br><span class="line">brokerClusterName&#x3D;Data-Cluster</span><br><span class="line">#broker名字</span><br><span class="line">brokerName&#x3D;broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId&#x3D;0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr&#x3D;18.16.200.228:9876;18.16.200.238:9876;18.16.200.211:9876</span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums&#x3D;3</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable&#x3D;true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup&#x3D;true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort&#x3D;10911</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">#fileReservedTime&#x3D;3600</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;300000</span><br><span class="line">#destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line">#redeleteHangedFileInterval&#x3D;120000</span><br><span class="line">#文件磁盘最大利用率</span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store-b</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;commitlog-b</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;consumequeue-b</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line">#flushCommitLogLeastPages&#x3D;4</span><br><span class="line">#flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line">#flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line">#flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole&#x3D;ASYNC_MASTER</span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2m-2s-async/broker-c-s.properties    配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 2m-2s-async&#x2F;broker-c-s.properties </span><br><span class="line">#集群名</span><br><span class="line">brokerClusterName&#x3D;Data-Cluster</span><br><span class="line">#broker名字</span><br><span class="line">brokerName&#x3D;broker-c</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId&#x3D;1</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr&#x3D;18.16.200.228:9876;18.16.200.238:9876;18.16.200.211:9876</span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums&#x3D;3</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable&#x3D;ture</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup&#x3D;ture</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort&#x3D;20912</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">#fileReservedTime&#x3D;3600</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;300000</span><br><span class="line">#destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line">#redeleteHangedFileInterval&#x3D;120000</span><br><span class="line">#磁盘最大利用率</span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store-c-s</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;commitlog-c-s</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;consumequeue-c-s</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line">#flushCommitLogLeastPages&#x3D;4</span><br><span class="line">#flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line">#flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line">#flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole&#x3D;SLAVE</span><br><span class="line">#brokerRole&#x3D;ASYNC_MASTER</span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="192-168-1-12配置文件"><a href="#192-168-1-12配置文件" class="headerlink" title="192.168.1.12配置文件"></a>192.168.1.12配置文件</h3><p>broker.conf配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat broker.conf</span><br><span class="line">brokerClusterName &#x3D; DefaultCluster</span><br><span class="line">brokerName &#x3D; broker-c</span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line">fileReservedTime &#x3D; 48</span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br></pre></td></tr></table></figure>
<p>2m-2s-async/broker-c.properties 配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 2m-2s-async&#x2F;broker-c.properties </span><br><span class="line">#集群名</span><br><span class="line">brokerClusterName&#x3D;Data-Cluster</span><br><span class="line">#broker名字</span><br><span class="line">brokerName&#x3D;broker-c</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId&#x3D;0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr&#x3D;18.16.200.228:9876;18.16.200.238:9876;18.16.200.211:9876</span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums&#x3D;3</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable&#x3D;true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup&#x3D;true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">#listenPort&#x3D;10911</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">#fileReservedTime&#x3D;3600</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;300000</span><br><span class="line">#destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line">#redeleteHangedFileInterval&#x3D;120000</span><br><span class="line">#文件磁盘最大利用率</span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store-c</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;commitlog-c</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;consumequeue-c</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line">#flushCommitLogLeastPages&#x3D;4</span><br><span class="line">#flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line">#flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line">#flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole&#x3D;ASYNC_MASTER</span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2m-2s-async/broker-a-s.properties  配置文件详解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 2m-2s-async&#x2F;broker-a-s.properties </span><br><span class="line">#集群名</span><br><span class="line">brokerClusterName&#x3D;Data-Cluster</span><br><span class="line">#broker名字</span><br><span class="line">brokerName&#x3D;broker-a</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId&#x3D;1</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr&#x3D;18.16.200.228:9876;18.16.200.238:9876;18.16.200.211:9876</span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums&#x3D;3</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable&#x3D;ture</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup&#x3D;ture</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort&#x3D;20912</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">#fileReservedTime&#x3D;3600</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;300000</span><br><span class="line">#destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line">#redeleteHangedFileInterval&#x3D;120000</span><br><span class="line">#磁盘最大利用率</span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store-a-s</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;commitlog-a-s</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;consumequeue-a-s</span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line">#flushCommitLogLeastPages&#x3D;4</span><br><span class="line">#flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line">#flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line">#flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole&#x3D;SLAVE</span><br><span class="line">#brokerRole&#x3D;ASYNC_MASTER</span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br></pre></td></tr></table></figure>
<h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ROCKETMQ_HOME&#x3D;&#x2F;opt&#x2F;rocketmq</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_271&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_271&#x2F;jre&#x2F;bin:&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;bin:&#x2F;opt&#x2F;rocketmq&#x2F;bin</span><br></pre></td></tr></table></figure>
<h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><h3 id="启动nameserver"><a href="#启动nameserver" class="headerlink" title="启动nameserver"></a>启动nameserver</h3><p>三台机器分别运行这个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup sh mqnamesrv &gt; &#x2F;data&#x2F;logs&#x2F;rocketmq&#x2F;mqnamesrv.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<h3 id="启动broker的master配置"><a href="#启动broker的master配置" class="headerlink" title="启动broker的master配置"></a>启动broker的master配置</h3><p>192.168.1.10上执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup sh mqbroker -c &#x2F;opt&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-a.properties&gt;&#x2F;data&#x2F;logs&#x2F;rocketmq&#x2F;mqbroker-a.log 2&gt;&amp;1 &amp;</span><br><span class="line">nohup sh mqbroker -c &#x2F;opt&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-b-s.properties &gt;&gt;&#x2F;data&#x2F;logs&#x2F;rocketmq&#x2F;mqbroker-b-s.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>192.168.1.11上执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup sh mqbroker -c &#x2F;opt&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-b.properties &gt; &#x2F;data&#x2F;logs&#x2F;rocketmq&#x2F;mqbroker-b.log 2&gt;&amp;1 &amp;</span><br><span class="line">nohup sh mqbroker -c &#x2F;opt&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-c-s.properties &gt; &#x2F;data&#x2F;logs&#x2F;rocketmq&#x2F;mqbroker-c-s.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>192.168.1.12上执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup sh mqbroker -c &#x2F;opt&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-c.properties &gt;&gt; &#x2F;data&#x2F;logs&#x2F;rocketmq&#x2F;mqbroker-c.log 2&gt;&amp;1 &amp;</span><br><span class="line">nohup sh mqbroker -c &#x2F;opt&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-a-s.properties &gt;&gt; &#x2F;data&#x2F;logs&#x2F;rocketmq&#x2F;mqbroker-a-s.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>linux</category>
        <category>rockermq</category>
        <category>消息队列</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>linux</tag>
        <tag>rockermq</tag>
        <tag>消息队列</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS--引入方式</title>
    <url>/post/8f3930ab.html</url>
    <content><![CDATA[<h1 id="CSS–引入方式"><a href="#CSS–引入方式" class="headerlink" title="CSS–引入方式"></a>CSS–引入方式</h1><h2 id="css介绍"><a href="#css介绍" class="headerlink" title="css介绍"></a>css介绍</h2><p>==<code>css(Cascading Style Sheet)</code>层叠样式表，它是用来美化页面的一种语言。==</p>
<ul>
<li>美化界面, 比如: 设置标签文字大小、颜色、字体加粗等样式。</li>
<li>控制页面布局, 比如: 设置浮动、定位等样式。</li>
</ul>
<a id="more"></a>
<h2 id="css基本语法"><a href="#css基本语法" class="headerlink" title="css基本语法"></a>css基本语法</h2><blockquote>
<p>选择器:是用来选择标签的，选出来以后给标签加样式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">样式规则</span><br><span class="line">&#125;</span><br><span class="line">样式规则：</span><br><span class="line">属性名1：属性值1;</span><br><span class="line">属性名2：属性值2;</span><br><span class="line">属性名3：属性值3;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="css简单实例"><a href="#css简单实例" class="headerlink" title="css简单实例"></a>css简单实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!-- 所有css样式最外层需要使用style标签 --&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        &#x2F;* div标签选择器 *&#x2F;</span><br><span class="line">        div &#123;</span><br><span class="line">            &#x2F;* 设置标签宽度 *&#x2F;</span><br><span class="line">            width: 100px;</span><br><span class="line">            &#x2F;* 设置标签的高度 *&#x2F;</span><br><span class="line">            height: 100px;</span><br><span class="line">            &#x2F;* 设置标签的背景 *&#x2F;</span><br><span class="line">            background: gold;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 显示内容的内容 --&gt;</span><br><span class="line">    &lt;div&gt;内容&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="css引入方式–-行内式"><a href="#css引入方式–-行内式" class="headerlink" title="css引入方式– 行内式"></a>css引入方式– 行内式</h2><p>==直接在标签的<code>style</code>属性中添加 <code>css</code> 样式==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;width:100px; height:100px; background:red &quot;&gt;hello&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="css引入方式–-内嵌式（内部样式）"><a href="#css引入方式–-内嵌式（内部样式）" class="headerlink" title="css引入方式– 内嵌式（内部样式）"></a>css引入方式– 内嵌式（内部样式）</h2><p>==在<code>&lt;head&gt;</code>标签内加入<code>&lt;style&gt;</code>标签，在<code>&lt;style&gt;</code>标签中编写<code>css</code>代码。==</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">        div &#123;</span><br><span class="line"><span class="css">           <span class="comment">/* 宽度 */</span></span></span><br><span class="line">           width: 100px;</span><br><span class="line"><span class="css">           <span class="comment">/* 高度 */</span></span></span><br><span class="line">           height: 200px;</span><br><span class="line"><span class="css">           <span class="comment">/* 背景色 */</span></span></span><br><span class="line">           background: red; </span><br><span class="line">           &#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="css引入方式–-外链式"><a href="#css引入方式–-外链式" class="headerlink" title="css引入方式– 外链式"></a>css引入方式– 外链式</h2><p>==将<code>css</code>代码写在一个单独的<code>.css</code>文件中，在<code>&lt;head&gt;</code>标签中使用<code>&lt;link&gt;</code>标签直接引入该文件到页面中。==</p>
<blockquote>
<p>css文件的代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">   &#x2F;* 宽度 *&#x2F;</span><br><span class="line">   width: 100px;</span><br><span class="line">   &#x2F;* 高度 *&#x2F;</span><br><span class="line">   height: 200px;</span><br><span class="line">   &#x2F;* 背景色 *&#x2F;</span><br><span class="line">   background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>html文件的代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- href中指定css文件导入路径 --&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;main.css&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：<ul>
<li>使得css样式与html页面分离，便于整个页面系统的规划和维护，可重用性高。</li>
</ul>
</li>
<li>缺点：<ul>
<li>   css代码由于分离到单独的css文件，容易出现css代码过于集中，若维护不当则极容易造成混乱。</li>
</ul>
</li>
</ul>
<h2 id="css引入方式的选择"><a href="#css引入方式的选择" class="headerlink" title="css引入方式的选择"></a>css引入方式的选择</h2><ul>
<li>行内式几乎不用</li>
<li>内嵌式在学习css样式的阶段使用</li>
<li>外链式在公司开发的阶段使用，可以对 css 样式和 html 页面分别进行开发。</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS--选择器</title>
    <url>/post/dda20804.html</url>
    <content><![CDATA[<h1 id="CSS–选择器"><a href="#CSS–选择器" class="headerlink" title="CSS–选择器"></a>CSS–选择器</h1><h2 id="CSS概述"><a href="#CSS概述" class="headerlink" title="CSS概述"></a>CSS概述</h2><p>CSS 指层叠样式表 (Cascading Style Sheets),样式表允许以多种方式进行规定样式信息,这个就是之前说过的<code>CSS</code>的三种引入方式,打个比方:加入<code>html</code>是骨架,那么<code>CSS</code>就是各种各样的躯体.用来充实骨架,这样才有了形形色色的人们.</p>
<a id="more"></a>
<h2 id="选择器的定义"><a href="#选择器的定义" class="headerlink" title="选择器的定义"></a>选择器的定义</h2><p>==<code>css 选择器</code>是用来选择标签的，选出来以后给指定的标签添加对应的样式==</p>
<h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>==标签选择器根据标签名来选择标签，以标签名开头，此种选择器影响范围大，一般用来做一些通用设置。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        &#x2F;* 标签选择器,直接以标签名开头 *&#x2F;</span><br><span class="line">        p&#123;</span><br><span class="line">            &#x2F;* 设置颜色是红色 *&#x2F;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 网页展示的内容 --&gt;</span><br><span class="line">    &lt;div&gt;hello div&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;p&gt;hello p1&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;hello p2&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>==类选择器根据类名来选择标签，以 . 开头, 一个类选择器可应用于多个标签上，一个标签上也可以使用多个类选择器，多个类选择器需要使用空格分割，应用灵活，可复用，是css中应用最多的一种选择器。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        &#x2F;* 类选择器以.开头,后面填写需要被操作标签的类名 *&#x2F;</span><br><span class="line">    </span><br><span class="line">        &#x2F;* class中类名为div01的标签设置对应css样式 *&#x2F;</span><br><span class="line">        .div01&#123;</span><br><span class="line">            color:blue</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* class中类名为p01的标签设置对应css样式 *&#x2F;</span><br><span class="line">        .p01&#123;</span><br><span class="line">            color:red</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;* class中类名为box的标签设置对应css样式 *&#x2F;</span><br><span class="line">        .box&#123;</span><br><span class="line">            width:100px;</span><br><span class="line">            height:100px;</span><br><span class="line">            background:gold</span><br><span class="line">        &#125; </span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;div01&quot;&gt;这是一个div&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 这个标签可以设置多个类名 --&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;p01 box&quot;&gt;这是一个段落&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="层级选择器-后代选择器"><a href="#层级选择器-后代选择器" class="headerlink" title="层级选择器(后代选择器)"></a>层级选择器(后代选择器)</h2><p>==层级选择器根据层级关系选择后代标签，以 外层标签 内层标签，主要应用在标签嵌套的结构中，减少命名。<code>这个层级关系不一定是父子关系，也有可能是祖孙关系，只要有后代关系都适用于这个层级选择器</code>==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        &#x2F;* div 下在的p标签设置样式 *&#x2F;</span><br><span class="line">        div p&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;* 类名为con的标签下的类名为url的标签设置样式 *&#x2F;</span><br><span class="line">        .con .url&#123;</span><br><span class="line">            color:pink;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class&#x3D;&quot;con&quot;&gt;</span><br><span class="line">        &lt;p&gt;hello world&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; class&#x3D;&quot;url&quot;&gt;度娘&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;p&gt;你好&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;url&quot;&gt;百度&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="组选择器"><a href="#组选择器" class="headerlink" title="组选择器"></a>组选择器</h2><p>==组选择器可以把多个标签组成一个组，以, 分割, 如果有公共的样式设置，可以使用组选择器进行统一的样式设置。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        &#x2F;* 组选择器使用,对标签进行分隔 *&#x2F;</span><br><span class="line">      &#x2F;* 设置第一个与第三个div样式 *&#x2F;</span><br><span class="line">        .box1,</span><br><span class="line">        .box3 &#123;</span><br><span class="line">            &#x2F;* 设置宽度 *&#x2F;</span><br><span class="line">            width: 100px;</span><br><span class="line">            &#x2F;* 设置高度 *&#x2F;</span><br><span class="line">            height: 100px;</span><br><span class="line">            &#x2F;* 设置背影 *&#x2F;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box1&quot;&gt;这是第一个div&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box2&quot;&gt;这是第二个div&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box3&quot;&gt;这是第三个div&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>==id选择器，以#开头, 元素的id名称不能重复，所以id选择器只能对应于页面上一个元素，不能复用，所以不推荐使用id作为选择器。==</p>
<blockquote>
<p>在css里id名称是可以的相同的。但如果页面涉及到JavaScript，就有问题了。因为JavaScript里获取DOM是通过getElementById，如果页面出现同一个id多次的话，这样元素就获取不到了。所以id需要唯一性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        &#x2F;* id选择器以#号开始 *&#x2F;</span><br><span class="line">         #div01&#123;</span><br><span class="line">             color:red;</span><br><span class="line">         &#125; </span><br><span class="line">     </span><br><span class="line">         #div02&#123;</span><br><span class="line">             color:green;</span><br><span class="line">         &#125; </span><br><span class="line">     &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;div01&quot;&gt;这是第一个段落标签&lt;&#x2F;div&gt;   &lt;!-- 每个标签的id名称不能相同--&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;div02&#39;&gt;这是第二个段落标签&lt;&#x2F;div&gt; &lt;!-- 每个标签的id名称不能相同--&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>==属性选择器根据属性选择标签，以 标签名[属性名=’属性值’]开头, 一个属性选择器可应用于多个标签上==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        &#x2F;* 设置键为name值为hello的标签设置为红色 *&#x2F;</span><br><span class="line">    </span><br><span class="line">        [name&#x3D;&#39;hello&#39;]&#123;</span><br><span class="line">            color: red</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 设置hello world与hello summer字体颜色为红色 --&gt;</span><br><span class="line">    &lt;div name&#x3D;&quot;hello&quot;&gt; hello world&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div name&#x3D;&quot;baidu&quot;&gt; 百度 &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div name&#x3D;&quot;hello&quot;&gt; hello summer &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>html</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装及使用</title>
    <url>/post/5023a885.html</url>
    <content><![CDATA[<h1 id="Docker安装使用"><a href="#Docker安装使用" class="headerlink" title="Docker安装使用"></a>Docker安装使用</h1><h1 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h1><p>Linux 3.10 版本是在 2013 年 6 月底发布的，我们来看看上述几个 Linux 发行版何时开始使用该内核版本的：</p>
<table>
<thead>
<tr>
<th>发行版</th>
<th>版本</th>
<th>发布日期</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>CentOS</td>
<td>7.0-1406</td>
<td>2014 年 7 月</td>
<td>3.10.0-123</td>
</tr>
<tr>
<td>Debian</td>
<td>8.0</td>
<td>2015 年 4 月</td>
<td>Linux 3.16</td>
</tr>
<tr>
<td>Fedora</td>
<td>20</td>
<td>2013 年 12 月</td>
<td>3.11</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>13.10</td>
<td>2013 年 10 月</td>
<td>Linux 3.11</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>可以看到，不同的发行版会选择不同版本的内核。我们来看看现在这些发行版所用的内核版本：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>发行版</th>
<th>版本</th>
<th>发布日期</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>CentOS</td>
<td>7.7-1908</td>
<td>2019 年 9 月</td>
<td>3.10.0-1062</td>
</tr>
<tr>
<td>CentOS</td>
<td>8.0-1905</td>
<td>2019 年 9 月</td>
<td>4.18.0-80</td>
</tr>
<tr>
<td>Debian</td>
<td>10.0</td>
<td>2019 年 7 月</td>
<td>Linux 4.19</td>
</tr>
<tr>
<td>Fedora</td>
<td>30</td>
<td>2019 年 4 月</td>
<td>5.0</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>19.04</td>
<td>2019 年 4 月</td>
<td>Linux 5.0</td>
</tr>
</tbody></table>
<a id="more"></a>  
<p>可以看到内核版本更新最慢的是 CentOS，而一个很值得注意的点是，Linux 3.10 截至 Linux 3.10.108 就已经 EOL（End Of Life）了，<strong>CentOS使用的内核其实移植了很多高版本Linux 中的特性</strong> 。<br>我们举个实际的例子：Docker 的存储驱动，在早先版本中其实对于 CentOS 系统上一直是默认使用 Devicemapper 的存储驱动，但最近的Docker 版本中已经将 Devicemapper 标记为了废弃。所以我们推荐选择 Overlay2存储驱动。<br>Docker 的 Overlay2 存储驱动需要内核的 Multiple lower layers 支持，而 OverlayFS 是在 Linux 3.18时合并进入内核的，但在 Linux 3.19 版本时才添加了 Multiple lower layers 的支持。<br>Linux 3.19 恰好是 3.x 系列的最后一个版本，两个月后 4.0 便发布了，通常情况下，人们会更推荐采用<br>4.0。所以<a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">官方文档</a>上对于使用 Overlay2 存储驱动的建议是使用 Linux 4.0 及更高版本的内核。</p>
<p>而 CentOS 的内核中存在大量的反向移植，Mmultiple lower layers 的特性也被移植到了 CentOS 7.4的内核之上。所以如果你只是考虑使用 Overlay2 作为存储驱动的话，则至少需要选择 CentOS 7.4 内核版本为 3.10.0-693或者更新版本的内核。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以防你已经安装或者安装失败</span><br><span class="line">yum remove -y docker-ce \</span><br><span class="line">			  docker-client \</span><br><span class="line">			  docker-client-latest \</span><br><span class="line">			  docker-common \</span><br><span class="line">			  docker-latest \</span><br><span class="line">			  docker-latest-logrotate \</span><br><span class="line">			  docker-logrotate \</span><br><span class="line">			  docker-engine</span><br><span class="line"></span><br><span class="line"># 安装yum软件包</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"># 设置阿里云镜像仓库</span><br><span class="line">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 更新软件包索引</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"># 查看yum 版本</span><br><span class="line">yum list docker-ce.x86_64  --showduplicates |sort -r</span><br><span class="line"></span><br><span class="line"># 根据需求安装，如果yum安装是直接安装最新版本</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"># 使用containerd管理容器（Linux系统内核支持，优化程度相对比较高）</span><br><span class="line"># 使用 systemd，编辑docker配置文件,中间内容如下</span><br><span class="line">mkdir &#x2F;data&#x2F;docker -pv</span><br><span class="line">vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line"># for containers run by docker</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F; --containerd&#x3D;&#x2F;run&#x2F;containerd&#x2F;containerd.sock \</span><br><span class="line">                                    --init \</span><br><span class="line">                                    --live-restore \</span><br><span class="line">                                    --exec-opt native.cgroupdriver&#x3D;systemd \</span><br><span class="line">                                    --data-root&#x3D;&#x2F;data&#x2F;docker \</span><br><span class="line">                                    --log-driver json-file \</span><br><span class="line">                                    --log-opt max-size&#x3D;100m \</span><br><span class="line">                                    --log-opt max-file&#x3D;3</span><br><span class="line"></span><br><span class="line"># 配置Daocloud的镜像加速器，或者你可以配置阿里云的镜像加速器</span><br><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io</span><br><span class="line"># 阿里dockerhub镜像加速器，登录阿里云，打开这个链接，然后配置按照阿里云的提示配置即可</span><br><span class="line">https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;cn-huhehaote&#x2F;instances&#x2F;mirrors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动 docker, 并设置自动启动</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果报错 请使用 一般不会有问题的，没有安装成功可能是你之前安装过，导致的问题，可以直接试用于生产环境，我目前全量就跑的是这个</span><br><span class="line">journalctl -fu docker </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker--Docker运行是资源限制</title>
    <url>/post/995b8fff.html</url>
    <content><![CDATA[<h1 id="Docker–Docker运行是资源限制"><a href="#Docker–Docker运行是资源限制" class="headerlink" title="Docker–Docker运行是资源限制"></a>Docker–Docker运行是资源限制</h1><p>Docker 提供的内存限制功能有以下几点：<br>一般情况下，达到内存限制的容器过段时间后就会被系统杀死</p>
<ul>
<li>容器能使用的内存和交换分区大小。</li>
<li>容器的核心内存大小。</li>
<li>容器虚拟内存的交换行为。</li>
<li>容器内存的软性限制。</li>
<li>是否杀死占用过多内存的容器。</li>
<li>容器被杀死的优先级</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker--k8s证书过期解决方案</title>
    <url>/post/de69e2d6.html</url>
    <content><![CDATA[<h1 id="查看集群证书过期情况"><a href="#查看集群证书过期情况" class="headerlink" title="查看集群证书过期情况"></a>查看集群证书过期情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm alpha certs check-expiration</span><br><span class="line">[check-expiration] Reading configuration from the cluster...</span><br><span class="line">[check-expiration] FYI: You can look at this config file with &#39;kubectl -n kube-system get cm kubeadm-config -oyaml&#39;</span><br><span class="line"></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Dec 29, 2021 06:53 UTC   358d                                    no</span><br><span class="line">apiserver                  Dec 29, 2021 06:53 UTC   358d            ca                      no</span><br><span class="line">apiserver-etcd-client      Dec 29, 2021 06:53 UTC   358d            etcd-ca                 no</span><br><span class="line">apiserver-kubelet-client   Dec 29, 2021 06:53 UTC   358d            ca                      no</span><br><span class="line">controller-manager.conf    Dec 29, 2021 06:53 UTC   358d                                    no</span><br><span class="line">etcd-healthcheck-client    Dec 29, 2021 06:53 UTC   358d            etcd-ca                 no</span><br><span class="line">etcd-peer                  Dec 29, 2021 06:53 UTC   358d            etcd-ca                 no</span><br><span class="line">etcd-server                Dec 29, 2021 06:53 UTC   358d            etcd-ca                 no</span><br><span class="line">front-proxy-client         Dec 29, 2021 06:53 UTC   358d            front-proxy-ca          no</span><br><span class="line">scheduler.conf             Dec 29, 2021 06:53 UTC   358d                                    no</span><br><span class="line"></span><br><span class="line">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">ca                      Dec 23, 2029 11:49 UTC   8y              no</span><br><span class="line">etcd-ca                 Dec 23, 2029 11:49 UTC   8y              no</span><br><span class="line">front-proxy-ca          Dec 23, 2029 11:49 UTC   8y              no</span><br></pre></td></tr></table></figure>
<a id="more"></a>  
<h1 id="查看根CA证书的有效期"><a href="#查看根CA证书的有效期" class="headerlink" title="查看根CA证书的有效期"></a>查看根CA证书的有效期</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;kubernetes&#x2F;pki</span><br><span class="line"># 当前证书是10年的证书,可以直接生成, 如果和上面&#96;EXPIRES&#96; 日期是一样的是不适用</span><br><span class="line">ls | grep ca.crt | xargs -I &#123;&#125; openssl x509 -text -in &#123;&#125; | grep &quot;Not After&quot;</span><br><span class="line">            Not After : Dec 23 11:49:43 2029 GMT</span><br><span class="line">            Not After : Dec 23 11:49:44 2029 GMT</span><br></pre></td></tr></table></figure>
<h1 id="查看证书目录结构"><a href="#查看证书目录结构" class="headerlink" title="查看证书目录结构"></a>查看证书目录结构</h1><p>kubelet 上一般不会明确指定服务端证书, 而是只指定 ca 根证书, 让 kubelet 根据本地主机信息自动生成服务端证书并保存到配置的cert-dir文件夹中。</p>
<h2 id="Kubernetes-集群根证书"><a href="#Kubernetes-集群根证书" class="headerlink" title="Kubernetes 集群根证书"></a>Kubernetes 集群根证书</h2><p>== /etc/kubernetes/pki/ca.crt 根证书 ==<br>== /etc/kubernetes/pki/ca.key 根证书 ==</p>
<h2 id="其他证书均为根证书签发"><a href="#其他证书均为根证书签发" class="headerlink" title="其他证书均为根证书签发"></a>其他证书均为根证书签发</h2><ul>
<li>kube-apiserver 组件持有的服务端证书<br>　　/etc/kubernetes/pki/apiserver.crt<br>　　/etc/kubernetes/pki/apiserver.key</li>
<li>kubelet 组件持有的客户端证书<br>　　/etc/kubernetes/pki/apiserver-kubelet-client.crt<br>　　/etc/kubernetes/pki/apiserver-kubelet-client.key<h2 id="汇聚层-aggregator-证书"><a href="#汇聚层-aggregator-证书" class="headerlink" title="汇聚层(aggregator)证书"></a>汇聚层(aggregator)证书</h2>== /etc/kubernetes/pki/front-proxy-ca.crt ==<br>== /etc/kubernetes/pki/front-proxy-ca.key ==</li>
<li>代理端使用的客户端证书, 用作代用户与 kube-apiserver 认证<br>  /etc/kubernetes/pki/front-proxy-client.crt<br>  /etc/kubernetes/pki/front-proxy-client.key<h2 id="etcd-集群根证书"><a href="#etcd-集群根证书" class="headerlink" title="etcd 集群根证书"></a>etcd 集群根证书</h2>== /etc/kubernetes/pki/etcd/ca.crt ==<br>== /etc/kubernetes/pki/etcd/ca.key ==</li>
<li>etcd server 持有的服务端证书<br>  /etc/kubernetes/pki/etcd/server.crt<br>  /etc/kubernetes/pki/etcd/server.key</li>
<li>peer 集群中节点互相通信使用的客户端证书<br>  /etc/kubernetes/pki/etcd/peer.crt<br>  /etc/kubernetes/pki/etcd/peer.key</li>
<li>pod 中定义 Liveness 探针使用的客户端证书<br>  /etc/kubernetes/pki/etcd/healthcheck-client.crt<br>  /etc/kubernetes/pki/etcd/healthcheck-client.key</li>
<li>配置在 kube-apiserver 中用来与 etcd server 做双向认证的客户端证书<br>  /etc/kubernetes/pki/apiserver-etcd-client.crt<br>  /etc/kubernetes/pki/apiserver-etcd-client.key<h2 id="Serveice-Account秘钥"><a href="#Serveice-Account秘钥" class="headerlink" title="Serveice Account秘钥"></a>Serveice Account秘钥</h2>== /etc/kubernetes/pki/sa.key ==<br>== /etc/kubernetes/pki/sa.pub ==<br>这组的密钥对儿仅提供给 kube-controller-manager 使用. kube-controller-manager 通过 sa.key 对 token 进行签名, master 节点通过公钥 sa.pub 进行签名的验证.<br>API Server的authenticating环节支持多种身份校验方式：client cert、bearer token、static password auth等，这些方式中有一种方式通过authenticating（Kubernetes API Server会逐个方式尝试），那么身份校验就会通过。一旦API Server发现client发起的request使用的是service account token的方式，API Server就会自动采用signed bearer token方式进行身份校验。而request就会使用携带的service account token参与验证。该token是API Server在创建service account时用API server启动参数：–service-account-key-file的值签署(sign)生成的。如果–service-account-key-file未传入任何值，那么将默认使用–tls-private-key-file的值，即API Server的私钥（server.key）。<br>通过authenticating后，API Server将根据Pod username所在的group：system:serviceaccounts和system:serviceaccounts:(NAMESPACE)的权限对其进行authority 和admission control两个环节的处理。在这两个环节中，cluster管理员可以对service account的权限进行细化设置。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#96;pki&#96;目录下属于根证书目录</span><br><span class="line"># &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt 根证书</span><br><span class="line"># &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.key 根证书</span><br><span class="line"># </span><br><span class="line">tree &#x2F;etc&#x2F;kubernetes&#x2F;pki</span><br><span class="line">	&#x2F;etc&#x2F;kubernetes&#x2F;pki</span><br><span class="line">	├── apiserver.crt</span><br><span class="line">	├── apiserver-etcd-client.crt</span><br><span class="line">	├── apiserver-etcd-client.key</span><br><span class="line">	├── apiserver.key</span><br><span class="line">	├── apiserver-kubelet-client.crt</span><br><span class="line">	├── apiserver-kubelet-client.key</span><br><span class="line">	├── ca.crt</span><br><span class="line">	├── ca.key</span><br><span class="line">	├── etcd</span><br><span class="line">	│   ├── ca.crt</span><br><span class="line">	│   ├── ca.key</span><br><span class="line">	│   ├── healthcheck-client.crt</span><br><span class="line">	│   ├── healthcheck-client.key</span><br><span class="line">	│   ├── peer.crt</span><br><span class="line">	│   ├── peer.key</span><br><span class="line">	│   ├── server.crt</span><br><span class="line">	│   └── server.key</span><br><span class="line">	├── front-proxy-ca.crt</span><br><span class="line">	├── front-proxy-ca.key</span><br><span class="line">	├── front-proxy-client.crt</span><br><span class="line">	├── front-proxy-client.key</span><br><span class="line">	├── sa.key</span><br><span class="line">	└── sa.pub</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 备份原有证书</span><br><span class="line">cp -rp &#x2F;etc&#x2F;kubernetes &#x2F;etc&#x2F;kubernetes.bak</span><br><span class="line"># 备份etcd数据目录</span><br><span class="line">cp -r &#x2F;var&#x2F;lib&#x2F;etcd &#x2F;var&#x2F;lib&#x2F;etcd.bak</span><br></pre></td></tr></table></figure>
<h1 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h1><h2 id="生成集群配置的yaml文件"><a href="#生成集群配置的yaml文件" class="headerlink" title="生成集群配置的yaml文件"></a>生成集群配置的yaml文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm config view &gt; &#x2F;root&#x2F;kubeadm.yaml</span><br><span class="line">cat &#x2F;root&#x2F;kubeadm.yaml</span><br><span class="line">apiServer:</span><br><span class="line">  extraArgs:</span><br><span class="line">    authorization-mode: Node,RBAC</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta2</span><br><span class="line">certificatesDir: &#x2F;etc&#x2F;kubernetes&#x2F;pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  type: CoreDNS</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: &#x2F;var&#x2F;lib&#x2F;etcd</span><br><span class="line">imageRepository: k8s.gcr.io</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.17.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  podSubnet: 10.244.0.0&#x2F;16</span><br><span class="line">  serviceSubnet: 10.96.0.0&#x2F;12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="证书更新使用帮助"><a href="#证书更新使用帮助" class="headerlink" title="证书更新使用帮助"></a>证书更新使用帮助</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm alpha certs renew --help</span><br><span class="line">Usage:</span><br><span class="line">  kubeadm alpha certs renew [flags]</span><br><span class="line">  kubeadm alpha certs renew [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  admin.conf               Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself</span><br><span class="line">  all                      Renew all available certificates</span><br><span class="line">  apiserver                Renew the certificate for serving the Kubernetes API</span><br><span class="line">  apiserver-etcd-client    Renew the certificate the apiserver uses to access etcd</span><br><span class="line">  apiserver-kubelet-client Renew the certificate for the API server to connect to kubelet</span><br><span class="line">  controller-manager.conf  Renew the certificate embedded in the kubeconfig file for the controller manager to use</span><br><span class="line">  etcd-healthcheck-client  Renew the certificate for liveness probes to healthcheck etcd</span><br><span class="line">  etcd-peer                Renew the certificate for etcd nodes to communicate with each other</span><br><span class="line">  etcd-server              Renew the certificate for serving etcd</span><br><span class="line">  front-proxy-client       Renew the certificate for the front proxy client</span><br><span class="line">  scheduler.conf           Renew the certificate embedded in the kubeconfig file for the scheduler manager to use</span><br></pre></td></tr></table></figure>
<h2 id="更新证书操作"><a href="#更新证书操作" class="headerlink" title="更新证书操作"></a>更新证书操作</h2>每个master节点都需要执行的, 切记切记<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 更新所有服务的证书,如果不确定可以先更新一个看下结果用检查证书的命令, 上面的用法上有指定单独服务的名称</span><br><span class="line">kubeadm alpha certs renew all --config&#x3D;&#x2F;root&#x2F;kubeadm.yaml</span><br><span class="line">[renew] Reading configuration from the cluster...</span><br><span class="line">[renew] FYI: You can look at this config file with &#39;kubectl -n kube-system get cm kubeadm-config -oyaml&#39;</span><br><span class="line"></span><br><span class="line">certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself renewed</span><br><span class="line">certificate for serving the Kubernetes API renewed</span><br><span class="line">certificate the apiserver uses to access etcd renewed</span><br><span class="line">certificate for the API server to connect to kubelet renewed</span><br><span class="line">certificate embedded in the kubeconfig file for the controller manager to use renewed</span><br><span class="line">certificate for liveness probes to healthcheck etcd renewed</span><br><span class="line">certificate for etcd nodes to communicate with each other renewed</span><br><span class="line">certificate for serving etcd renewed</span><br><span class="line">certificate for the front proxy client renewed</span><br><span class="line">certificate embedded in the kubeconfig file for the scheduler manager to use renewed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="再次查询证书期限"><a href="#再次查询证书期限" class="headerlink" title="再次查询证书期限"></a>再次查询证书期限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root @ master ➜  pki  kubeadm alpha certs check-expiration</span><br><span class="line">[check-expiration] Reading configuration from the cluster...</span><br><span class="line">[check-expiration] FYI: You can look at this config file with &#39;kubectl -n kube-system get cm kubeadm-config -oyaml&#39;</span><br><span class="line"></span><br><span class="line">CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span><br><span class="line">admin.conf                 Jan 04, 2022 07:55 UTC   364d                                    no</span><br><span class="line">apiserver                  Jan 04, 2022 07:55 UTC   364d            ca                      no</span><br><span class="line">apiserver-etcd-client      Jan 04, 2022 07:55 UTC   364d            etcd-ca                 no</span><br><span class="line">apiserver-kubelet-client   Jan 04, 2022 07:55 UTC   364d            ca                      no</span><br><span class="line">controller-manager.conf    Jan 04, 2022 07:55 UTC   364d                                    no</span><br><span class="line">etcd-healthcheck-client    Jan 04, 2022 07:55 UTC   364d            etcd-ca                 no</span><br><span class="line">etcd-peer                  Jan 04, 2022 07:55 UTC   364d            etcd-ca                 no</span><br><span class="line">etcd-server                Jan 04, 2022 07:55 UTC   364d            etcd-ca                 no</span><br><span class="line">front-proxy-client         Jan 04, 2022 07:55 UTC   364d            front-proxy-ca          no</span><br><span class="line">scheduler.conf             Jan 04, 2022 07:55 UTC   364d                                    no</span><br><span class="line"></span><br><span class="line">CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span><br><span class="line">ca                      Dec 23, 2029 11:49 UTC   8y              no</span><br><span class="line">etcd-ca                 Dec 23, 2029 11:49 UTC   8y              no</span><br><span class="line">front-proxy-ca          Dec 23, 2029 11:49 UTC   8y              no</span><br></pre></td></tr></table></figure>
<h1 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h1>如果上述操作执行之后集群就恢复了,可以不执行如下操作, 但是没有的话,尝试下如下的命令.<br>命令的作用是直接重启下和证书相关的应用的容器,重新加载证书.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps |grep -E &#39;k8s_kube-apiserver|k8s_kube-controller-manager|k8s_kube-scheduler|k8s_etcd_etcd&#39; | awk -F &#39; &#39; &#39;&#123;print $1&#125;&#39; |xargs docker restart</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
        <category>k8s</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker--外部访问K8s中Pod的五种方式</title>
    <url>/post/beab2e09.html</url>
    <content><![CDATA[<h1 id="HostNetwork"><a href="#HostNetwork" class="headerlink" title="HostNetwork"></a>HostNetwork</h1><p>这是一种直接定义Pod网络的方式。<br>如果在Pod中使用<code>hostNetwork:true</code>配置的话，在这种pod中运行的应用程序可以直接看到pod启动的主机的网络接口。在主机的所有网络接口上都可以访问到该应用程序.<br>一般配合k8s的亲和使用,需要配置<code>nodeSelector</code>.</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tmpcluster-master-1 ~]# cat hostNetwork.yaml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: redis</span><br><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  containers:</span><br><span class="line">    - name: redis</span><br><span class="line">      image: redis</span><br><span class="line">      imagePullPolicy: IfNotPresent</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">[root@tmpcluster-master-1 ~]# kubectl get pods -o wide</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    IP              NODE                  NOMINATED NODE   READINESS GATES</span><br><span class="line">redis   1&#x2F;1     Running   0          101m   18.16.203.103   tmpcluster-worker-1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">[root@tmpcluster-master-1 ~]# ssh tmpcluster-worker-1</span><br><span class="line">Last login: Wed Mar 31 16:02:41 2021 from 18.16.200.2</span><br><span class="line"></span><br><span class="line">[root@tmpcluster-worker-1 ~]# ss -natlp|grep 637</span><br><span class="line">LISTEN     0      128          *:6379                     *:*                   users:((&quot;redis-server&quot;,pid&#x3D;330350,fd&#x3D;6))</span><br><span class="line">LISTEN     0      128         :::6379                    :::*                   users:((&quot;redis-server&quot;,pid&#x3D;330350,fd&#x3D;7))</span><br><span class="line"></span><br><span class="line">[root@tmpcluster-master-1 ~]# telnet  18.16.203.103 6379</span><br><span class="line">Trying 18.16.203.103...</span><br><span class="line">Connected to 18.16.203.103.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="HostPort"><a href="#HostPort" class="headerlink" title="HostPort"></a>HostPort</h1><p>hostPort是直接将容器的端口与所调度的节点上的端口映射，这样用户就可以通过宿主机的IP加上来访问Pod.<br>切记: 只能调度到没有端口冲突的node上, 需要单独维护pod和宿主机的关系表,相对来说比较麻烦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tmpcluster-master-1 ~]# cat hostPort.yaml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: redis</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: redis </span><br><span class="line">      image: redis</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 6379 </span><br><span class="line">          hostPort: 6379</span><br><span class="line">		  </span><br><span class="line">[root@tmpcluster-master-1 ~]# kubectl create -f hostPort.yaml </span><br><span class="line">[root@tmpcluster-master-1 ~]# telnet 18.16.203.103 6379</span><br><span class="line">Trying 18.16.203.103...</span><br><span class="line">Connected to 18.16.203.103.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h1><p>需要配合service使用,K8s中的service大部分情况都是使用Cluster IP这种类型，会产生一个只能在内部访问的Cluster IP，如果想能够直接访问service，需要将svc type修改为nodePort。同时给svc指定一个nodeport值(默认是从30001开始,也可以在设置中自行修改,然后重载docker配置)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tmpcluster-master-1 ~]# cat nodeport.yaml nodeport-svc.yaml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: redis</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: redis </span><br><span class="line">      image: redis</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: redis</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 6379 </span><br><span class="line">      nodePort: 30000</span><br><span class="line">  selector:</span><br><span class="line">    name: redis</span><br><span class="line"></span><br><span class="line">[root@tmpcluster-master-1 ~]# kubectl describe services redis </span><br><span class="line">Name:                     redis</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   &lt;none&gt;</span><br><span class="line">Annotations:              Selector:  name&#x3D;redis</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP:                       179.50.24.132</span><br><span class="line">Port:                     &lt;unset&gt;  6379&#x2F;TCP</span><br><span class="line">TargetPort:               6379&#x2F;TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  30000&#x2F;TCP</span><br><span class="line">Endpoints:                &lt;none&gt;</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br><span class="line"></span><br><span class="line">[root@tmpcluster-master-1 ~]# telnet 18.16.203.103 6379</span><br><span class="line">Trying 18.16.203.103...</span><br><span class="line">Connected to 18.16.203.103.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h1><p>只能在云上符合使用<br>创建服务时，可以选择自动创建云网络负载均衡器。这提供了一个外部可访问的 IP 地址， 可将流量分配到集群节点上的正确端口上 （ 假设集群在支持的环境中运行，并配置了正确的云负载平衡器提供商包）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tmpcluster-master-1 ~]#  cat k8s-yaml&#x2F;tmp-ns&#x2F;test-server&#x2F;test-server-svc.yaml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: test-server</span><br><span class="line">  annotations:</span><br><span class="line">    service.beta.kubernetes.io&#x2F;backend-type: &quot;eni&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-id: &quot;lb-xxxxxxxxxxxxx&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-force-override-listeners: &quot;true&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-protocol-port: &quot;http:4010&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-flag: &quot;on&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-type: &quot;http&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-uri: &quot;&#x2F;health&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-healthy-threshold: &quot;4&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-unhealthy-threshold: &quot;4&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-timeout: &quot;10&quot;</span><br><span class="line">    service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-interval: &quot;3&quot;</span><br><span class="line">  labels:</span><br><span class="line">    app: test-server</span><br><span class="line">  namespace: tmp-ns</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: test-server</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 4010</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8080</span><br><span class="line"></span><br><span class="line">[root@tmpcluster-master-1 ~]#  kubectl get svc security-server -n base-server</span><br><span class="line">NAME              TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE</span><br><span class="line">test-server   LoadBalancer   172.21.5.189   192.168.100.222   4010:30533&#x2F;TCP   10m</span><br><span class="line"></span><br><span class="line">[root@tmpcluster-master-1 ~]#  kubectl describe svc  test-server -n tmp-ns</span><br><span class="line">Name:                     test-server</span><br><span class="line">Namespace:                tmp-ns</span><br><span class="line">Labels:                   app&#x3D;test-server</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;hash&#x3D;b841232d1321323c1212327f50sd3a3sdf23b9fb78</span><br><span class="line">Annotations:              service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-force-override-listeners: true</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-flag: on</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-interval: 3</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-timeout: 10</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-type: http</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-health-check-uri: &#x2F;health</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-healthy-threshold: 4</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-id: lb-xxxxxxxxxxxxx</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-protocol-port: http:4010</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;alibaba-cloud-loadbalancer-unhealthy-threshold: 4</span><br><span class="line">                          service.beta.kubernetes.io&#x2F;backend-type: eni</span><br><span class="line">Selector:                 app&#x3D;test-server</span><br><span class="line">Type:                     LoadBalancer</span><br><span class="line">IP:                       172.21.5.189</span><br><span class="line">LoadBalancer Ingress:     192.168.100.222</span><br><span class="line">Port:                     http  4010&#x2F;TCP</span><br><span class="line">TargetPort:               8080&#x2F;TCP</span><br><span class="line">NodePort:                 http  30533&#x2F;TCP</span><br><span class="line">Endpoints:                192.168.22.46:8080,192.168.24.9:8080</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。<br>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。<br>可以将 Ingress 配置为服务提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及提供基于名称的虚拟主机等能力。 Ingress 控制器 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。<br>直接以域名的形式进行对外暴露, 可以配合负载均衡和dns解析使用,直接访问对应的域名即可.入口就是80端口，然后Ingress controller直接将流量转发给后端Pod，不需再经过kube-proxy的转发，比LoadBalancer方式更优选。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@tmpcluster-master-1 ~]#  cat test-ingress.yaml </span><br><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: test</span><br><span class="line">  namespace: test-service</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: aaa.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: test</span><br><span class="line">          servicePort: 4053</span><br><span class="line"></span><br><span class="line">[root@iZbp1egtbul3dj8svxv3x5Z ~]# kubectl get ingress yearning -n ops-service</span><br><span class="line">NAME       HOSTS              ADDRESS        PORTS   AGE</span><br><span class="line">yearning   aaa.com   22.22.22.22   80      172d</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
        <category>k8s</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker--本地镜像使用</title>
    <url>/post/d1906f5b.html</url>
    <content><![CDATA[<h1 id="列出本地镜像列表"><a href="#列出本地镜像列表" class="headerlink" title="列出本地镜像列表"></a>列出本地镜像列表</h1><p>REPOSITORY：表示镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              4bb46517cac3        2 weeks ago         133MB</span><br></pre></td></tr></table></figure>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               alpine              6f715d38cfe0        2 weeks ago         22.1MB</span><br><span class="line">nginx               latest              4bb46517cac3        2 weeks ago         133MB</span><br></pre></td></tr></table></figure>
<h1 id="获取新的镜像"><a href="#获取新的镜像" class="headerlink" title="获取新的镜像"></a>获取新的镜像</h1><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# docker pull nginx:alpine</span><br><span class="line">alpine: Pulling from library&#x2F;nginx</span><br><span class="line">df20fa9351a1: Pull complete</span><br><span class="line">3db268b1fe8f: Pull complete</span><br><span class="line">f682f0660e7a: Pull complete</span><br><span class="line">7eb0e8838bc0: Pull complete</span><br><span class="line">e8bf1226cc17: Pull complete</span><br><span class="line">Digest: sha256:a97eb9ecc708c8aa715ccfb5e9338f5456e4b65575daf304f108301f3b497314</span><br><span class="line">Status: Downloaded newer image for nginx:alpine</span><br><span class="line">docker.io&#x2F;library&#x2F;nginx:alpine</span><br></pre></td></tr></table></figure>
<h1 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h1><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/">https://hub.docker.com/</a> 我们也可以使用 docker search 命令来搜索镜像。</p>
<p>NAME: 镜像仓库源的名称<br>DESCRIPTION: 镜像的描述<br>OFFICIAL: 是否 docker 官方发布<br>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。<br>AUTOMATED: 自动构建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# docker search nginx</span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                              Official build of Nginx.                        13677               [OK]</span><br><span class="line">jwilder&#x2F;nginx-proxy                Automated Nginx reverse proxy for docker con…   1867                                    [OK]</span><br><span class="line">richarvey&#x2F;nginx-php-fpm            Container running Nginx + PHP-FPM capable of…   782                                     [OK]</span><br><span class="line">linuxserver&#x2F;nginx                  An Nginx container, brought to you by LinuxS…   127</span><br><span class="line">bitnami&#x2F;nginx                      Bitnami nginx Docker Image                      89                                      [OK]</span><br><span class="line">tiangolo&#x2F;nginx-rtmp                Docker image with Nginx using the nginx-rtmp…   88                                      [OK]</span><br><span class="line">jc21&#x2F;nginx-proxy-manager           Docker container for managing Nginx proxy ho…   82</span><br><span class="line">alfg&#x2F;nginx-rtmp                    NGINX, nginx-rtmp-module and FFmpeg from sou…   75                                      [OK]</span><br><span class="line">nginxdemos&#x2F;hello                   NGINX webserver that serves a simple page co…   59                                      [OK]</span><br><span class="line">jlesage&#x2F;nginx-proxy-manager        Docker container for Nginx Proxy Manager        53                                      [OK]</span><br><span class="line">nginx&#x2F;nginx-ingress                NGINX Ingress Controller for Kubernetes         41</span><br><span class="line">privatebin&#x2F;nginx-fpm-alpine        PrivateBin running on an Nginx, php-fpm &amp; Al…   32                                      [OK]</span><br><span class="line">schmunk42&#x2F;nginx-redirect           A very simple container to redirect HTTP tra…   19                                      [OK]</span><br></pre></td></tr></table></figure>
<h1 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h1><p>镜像删除使用 <code>docker rmi</code> 命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# docker rmi hello-world</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5</span><br><span class="line">Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b</span><br><span class="line">Deleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63</span><br></pre></td></tr></table></figure>

<h1 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h1><p>新镜像之前，我们需要使用镜像来创建一个容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]# docker run -itd centos:centos7.8.2003 &#x2F;bin&#x2F;bash</span><br><span class="line">4d95f2fd7cfb5ca53fd98eabfe4745815a9530ff7f593957d3b10b4b110318e3</span><br><span class="line">[root@centos7 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">4d95f2fd7cfb        centos:centos7.8.2003   &quot;&#x2F;bin&#x2F;bash&quot;         8 seconds ago       Up 7 seconds                            angry_cori</span><br><span class="line">[root@centos7 ~]# docker exec -it 4d95f2fd7cfb bash</span><br><span class="line">[root@4d95f2fd7cfb &#x2F;]# yum update -y</span><br></pre></td></tr></table></figure>
<p>各个参数说明：<br>-m: 提交的描述信息<br>-a: 指定镜像作者<br>e218edb10161：容器 ID(docker ps获取)<br>runoob/ubuntu:v2: 指定要创建的目标镜像名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 通过命令docker commit 来提交容器副本 创建新的镜像</span><br><span class="line">[root@centos7 ~]# docker commit -m&#x3D;&quot;yum update&quot; -a&#x3D;&quot;user&quot; 4d95f2fd7cfb user&#x2F;centos:v2</span><br><span class="line">sha256:8aee4e075a0d907c757bcc3946165447607bfe8d726888fad090fdc9ddda0718</span><br><span class="line"></span><br><span class="line"># 查看是否生产新的镜像</span><br><span class="line">[root@centos7 ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">user&#x2F;centos         v2                  8aee4e075a0d        12 seconds ago      203MB</span><br><span class="line"></span><br><span class="line"># 启动新的镜像容器</span><br><span class="line">[root@centos7 ~]# docker run -itd user&#x2F;centos:v2 &#x2F;bin&#x2F;bash</span><br><span class="line">799efd51587574113896b3c3218b08664b864c155490ca2728e65452a9f44901</span><br><span class="line"></span><br><span class="line"># 查看启动的容器</span><br><span class="line">[root@centos7 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">799efd515875        user&#x2F;centos:v2          &quot;&#x2F;bin&#x2F;bash&quot;         4 seconds ago       Up 3 seconds                            elastic_euclid</span><br><span class="line">4d95f2fd7cfb        centos:centos7.8.2003   &quot;&#x2F;bin&#x2F;bash&quot;         5 minutes ago       Up 5 minutes                            angry_cori</span><br><span class="line"></span><br><span class="line"># 停止旧的容器</span><br><span class="line">[root@centos7 ~]# docker stop 4d95f2fd7cfb</span><br><span class="line">4d95f2fd7cfb</span><br><span class="line"># 删除旧的容器</span><br><span class="line">[root@centos7 ~]# docker rm 4d95f2fd7cfb</span><br><span class="line">4d95f2fd7cfb</span><br><span class="line"># 查看剩余容器状态</span><br><span class="line">[root@centos7 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">799efd515875        user&#x2F;centos:v2      &quot;&#x2F;bin&#x2F;bash&quot;         3 minutes ago       Up 3 minutes                            elastic_euclid</span><br></pre></td></tr></table></figure>
<h1 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h1><p>使用 docker tag 命令，为镜像添加一个新的标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看镜像</span><br><span class="line">[root@centos7 ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               alpine              6f715d38cfe0        2 weeks ago         22.1MB</span><br><span class="line"></span><br><span class="line"># 为镜像搭上tag号</span><br><span class="line">[root@centos7 ~]# docker tag 6f715d38cfe0 nginx:new</span><br><span class="line"></span><br><span class="line"># 确认最终状态，生成两个镜像，可以理解为复制镜像</span><br><span class="line">[root@centos7 ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               alpine              6f715d38cfe0        2 weeks ago         22.1MB</span><br><span class="line">nginx               new                 6f715d38cfe0        2 weeks ago         22.1MB</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/post/0.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML--列表标签</title>
    <url>/post/2369968e.html</url>
    <content><![CDATA[<h1 id="HTML–列表标签"><a href="#HTML–列表标签" class="headerlink" title="HTML–列表标签"></a>HTML–列表标签</h1><h2 id="无序列表标签-ul标签"><a href="#无序列表标签-ul标签" class="headerlink" title="无序列表标签(ul标签)"></a>无序列表标签(ul标签)</h2><p>==无序列表是一个项目的列表，使用粗体圆点（典型的小黑圆圈）开头。==</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;!-- ul标签定义无序列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;!-- li标签定义列表项目 --&gt;</span><br><span class="line">    &lt;li&gt;列表标题一&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;列表标题二&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;列表标题三&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="有序列表标签-ol标签"><a href="#有序列表标签-ol标签" class="headerlink" title="有序列表标签(ol标签)"></a>有序列表标签(ol标签)</h2><p>==有序列表也是一列项目，列表项目使用数字开头。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- ol标签定义有序列表 --&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;!-- li标签定义列表项目 --&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;列表标题一&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;列表标题二&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;列表标题三&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML--常用标签</title>
    <url>/post/a7c11707.html</url>
    <content><![CDATA[<h1 id="HTML–常用标签"><a href="#HTML–常用标签" class="headerlink" title="HTML–常用标签"></a>HTML–常用标签</h1><h2 id="HTML元素-标签-分类"><a href="#HTML元素-标签-分类" class="headerlink" title="HTML元素(标签)分类"></a>HTML元素(标签)分类</h2><ul>
<li>块元素(行元素)</li>
<li>内联元素(行内元素)<h2 id="HTML–块元素-行元素"><a href="#HTML–块元素-行元素" class="headerlink" title="HTML–块元素(行元素)"></a>HTML–块元素(行元素)</h2><blockquote>
<p>特点: 单个块元素在浏览器中默认独占一行 块元素可以设置宽高等属性.</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h3 id="块元素之标题标签"><a href="#块元素之标题标签" class="headerlink" title="块元素之标题标签"></a>块元素之标题标签</h3><p>==表示文档的标题==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;一级标题&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;二级标题&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h3&gt;三级标题&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;h4&gt;四级标题&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;h5&gt;五级标题&lt;&#x2F;h5&gt;</span><br><span class="line">    &lt;h6&gt;六级标题&lt;&#x2F;h6&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="块元素之段落标签"><a href="#块元素之段落标签" class="headerlink" title="块元素之段落标签"></a>块元素之段落标签</h3><p>==表示文档中的一个文字段落==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        逢雪宿芙蓉山主人</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt; </span><br><span class="line">        日暮苍山远，天寒白屋贫。</span><br><span class="line">        柴门闻犬吠，风雪夜归人。</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="块元素之通用块容器标签"><a href="#块元素之通用块容器标签" class="headerlink" title="块元素之通用块容器标签"></a>块元素之通用块容器标签</h3><p>==表示文档中一块内容==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        逢雪宿芙蓉山主人</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt; </span><br><span class="line">        日暮苍山远，天寒白屋贫。</span><br><span class="line">        柴门闻犬吠，风雪夜归人。</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>


<h2 id="HTML–内联元素-行内元素"><a href="#HTML–内联元素-行内元素" class="headerlink" title="HTML–内联元素(行内元素)"></a>HTML–内联元素(行内元素)</h2><h3 id="内联元素之图片标签"><a href="#内联元素之图片标签" class="headerlink" title="内联元素之图片标签"></a>内联元素之图片标签</h3><p>==在网页中插入图片, 具有内联元素基本特性, 但是它支持宽高设置==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;test.png&quot; alt&#x3D;&quot;百度&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>src属性主要是添加要展示的图片地址</li>
<li>alt属性的作用:<ul>
<li>图片加载失败时, 显示的提示信息</li>
<li>搜索引擎在收录图片时, 根据这个属性值来收录图片</li>
<li>制作无障碍网页, 方便盲人的读屏软件读取.</li>
</ul>
</li>
</ul>
<h3 id="内联元素之超链接标签"><a href="#内联元素之超链接标签" class="headerlink" title="内联元素之超链接标签"></a>内联元素之超链接标签</h3><p>==链接到另外一个网页, 具有内联元素基本特征, 默认文字蓝色, 有下划线==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 超链接设置 --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;#&quot;&gt;默认链接&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;01.html&quot;&gt;第一个网页&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.google.com&quot;&gt;itcast&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;&lt;img src&#x3D;&quot;images&#x2F;logo.png&quot; alt&#x3D;&quot;&quot;&gt; &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这个会在新窗口打开内容 --&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;www.baidu.com&quot; target&#x3D;&quot;_blank&quot;&gt;新tab打开界面&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>a 标签的 href 属性可以添加 # 号, 这个是缺省链接地址:</p>
</li>
<li><p>不确定地址时, 我们可以临时使用 # 来占位,确定后替换即可</p>
</li>
<li><p>如果想要跳转到当前页面的最上方时, 可以使用 #</p>
</li>
<li><p>a 标签有 target 属性</p>
<ul>
<li>   如果不设置该属性, 在当前页面打开新页面</li>
<li>   如果设置该属性, 则会在新窗口中打开新页面</li>
</ul>
</li>
</ul>
<h3 id="内联元素之通用内联容器标签"><a href="#内联元素之通用内联容器标签" class="headerlink" title="内联元素之通用内联容器标签"></a>内联元素之通用内联容器标签</h3><p>==我们一般在文字段落的中间部分强调某一部分的时候调用span,添加样式,从而改变强调的部分的样式==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    公历12月25日是&lt;span style&#x3D;&quot;color:red&quot;&gt;圣诞节&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="特殊标签"><a href="#特殊标签" class="headerlink" title="特殊标签"></a>特殊标签</h2><ul>
<li><p>空格: 在html中, 空格一般会用<code>&amp;nbsp;</code>表示</p>
</li>
<li><p>回车: 在html中回车换行一般用<code>&lt;br&gt;</code>表示</p>
</li>
<li><p>小于号( &lt; ): 在html中一般用<code>&amp;lt;</code>表示</p>
</li>
<li><p>大于号( &gt; ): 在html中一般用<code>&amp;gt;</code>表示</p>
</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML--表单提交</title>
    <url>/post/3b35bf1d.html</url>
    <content><![CDATA[<h1 id="HTML–表单提交"><a href="#HTML–表单提交" class="headerlink" title="HTML–表单提交"></a>HTML–表单提交</h1><p>==表单用于搜集不同类型的用户输入(用户输入的数据)，然后可以把用户数据提交到web服务器==</p>
<h2 id="表单的基本标签"><a href="#表单的基本标签" class="headerlink" title="表单的基本标签"></a>表单的基本标签</h2><ul>
<li><p><code>&lt;form&gt; </code>标签 表示表单标签，定义整体的表单区域</p>
<ul>
<li><code>action</code>属性 设置表单数据提交地址</li>
<li><code>method</code>属性 设置表单提交的方式，一般有<code>“GET”</code>方式和<code>“POST”</code>方式, 不区分大小写</li>
</ul>
</li>
<li><p><label>标签 表示表单元素的文字标注标签，定义文字标注</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><code>&lt;input&gt;</code>标签 表示表单元素的用户输入标签，定义不同类型的用户输入数据方式,取决于 type 属性。<ul>
<li><code>type</code>属性<ul>
<li>   <code>type=&quot;text&quot; </code>定义单行文本输入框</li>
<li><code>type=&quot;submit&quot;</code> 定义提交按钮</li>
<li><code>type=radio</code> 单选按钮</li>
<li><code>type=checkbox</code> 复选按钮<h2 id="表单的元素属性设置"><a href="#表单的元素属性设置" class="headerlink" title="表单的元素属性设置"></a>表单的元素属性设置</h2></li>
</ul>
</li>
</ul>
</li>
<li><code>name</code>属性 设置表单元素的名称，该名称是提交数据时的参数名,提交表单字段必须有<code>name</code>属性</li>
<li><code>value</code>属性 设置表单元素的值，该值是提交数据时参数名所对应的参数值</li>
</ul>
<h2 id="表单的实例"><a href="#表单的实例" class="headerlink" title="表单的实例"></a>表单的实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 提交表单使用使用form包裹 --&gt;</span><br><span class="line">&lt;!-- action提交表单的地址 --&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;https:&#x2F;&#x2F;127.0.0.1:8080&#x2F;post_info.html&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;Car&quot; value&#x3D;&quot;Car&quot; &#x2F;&gt; car</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;House&quot; value&#x3D;&quot;House&quot; &#x2F;&gt; house</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;Boat&quot; value&#x3D;&quot;Boat&quot; &#x2F;&gt; boat</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;!-- 用户名输入框 --&gt;</span><br><span class="line">        &lt;label&gt;姓名：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;!-- 提交表单的按钮 --&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;male&quot; checked&gt;Male</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;female&quot;&gt;Female</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML-- 表单标签</title>
    <url>/post/e04b0b82.html</url>
    <content><![CDATA[<h1 id="HTML–-表单标签"><a href="#HTML–-表单标签" class="headerlink" title="HTML– 表单标签"></a>HTML– 表单标签</h1><p>==表单提交信息时候必须指定提交的参数名即设置标签中需要设置name属性==</p>
<ul>
<li><code>&lt;form&gt;</code>标签 表示表单标签，定义整体的表单区域</li>
<li><code>&lt;label&gt;</code>标签 表示表单元素的文字标注标签，定义文字标注</li>
<li><code>&lt;input&gt;</code>标签 表示表单元素的用户输入标签，定义不同类型的用户输入数据方式</li>
<li><code>type</code>属性<ul>
<li><code>type=&quot;text&quot; </code>定义单行文本输入框</li>
<li><code>type=&quot;password&quot; </code>定义密码输入框</li>
<li><code>type=&quot;radio&quot; </code>定义单选框</li>
<li><code>type=&quot;checkbox&quot; </code>定义复选框</li>
<li><code>type=&quot;file&quot; </code>定义上传文件</li>
<li><code>type=&quot;submit&quot; </code>定义提交按钮</li>
<li><code>type=&quot;reset&quot; </code>定义重置按钮</li>
<li><code>type=&quot;button&quot; </code>定义一个普通按钮</li>
<li><code>&lt;textarea&gt;</code>标签 表示表单元素的多行文本输入框标签 定义多行文本输入框</li>
</ul>
</li>
<li><code>&lt;select&gt;</code>标签 表示表单元素的下拉列表标签 定义下拉列表</li>
<li><code>&lt;option&gt;</code>标签 与<code>&lt;select&gt;</code>标签配合，定义下拉列表中的选项</li>
</ul>
<a id="more"></a>
<h2 id="表单标签的实例"><a href="#表单标签的实例" class="headerlink" title="表单标签的实例"></a>表单标签的实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 用户名:使用text类型,说明是文本--&gt;</span><br><span class="line">                    &lt;label&gt;姓名：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;user&quot;&gt;</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 用户名:使用password类型,文本输入会隐藏 --&gt;</span><br><span class="line">                    &lt;label&gt;密码：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pwd&quot;&gt;</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 姓别:使用radio类型,可以进行单选,注意name必须一致 --&gt;</span><br><span class="line">                    &lt;label&gt;性别：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&#39;sex&#39;&gt; 男</span><br><span class="line">                    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&#39;sex&#39;&gt; 女</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 爱好:使用checkbox类型,可以进行复选,注意必须指向name值 --&gt;</span><br><span class="line">                    &lt;label&gt;爱好：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;song&quot;&gt; 唱歌</span><br><span class="line">                    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;run&quot;&gt; 跑步</span><br><span class="line">                    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;dance&quot;&gt; 跳舞</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 照片:使用file类型 --&gt;</span><br><span class="line">                    &lt;label&gt;照片：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photo&quot;&gt;</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 个人描述:使用textarea标签 --&gt;</span><br><span class="line">                    &lt;label&gt;个人描述：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;textarea name&#x3D;&quot;desc&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 籍贯:使用select与option标签,注意select必须指向name值,option中必须指向name值 --&gt;</span><br><span class="line">                    &lt;label&gt;籍贯：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;select name&#x3D;&quot;city&quot;&gt;</span><br><span class="line">                        &lt;option value&#x3D;&quot;bj&quot;&gt;北京&lt;&#x2F;option&gt;</span><br><span class="line">                        &lt;option value&#x3D;&quot;sh&quot;&gt;上海&lt;&#x2F;option&gt;</span><br><span class="line">                        &lt;option value&#x3D;&quot;gz&quot;&gt;广州&lt;&#x2F;option&gt;</span><br><span class="line">                        &lt;option value&#x3D;&quot;sz&quot;&gt;深圳&lt;&#x2F;option&gt;</span><br><span class="line">                    &lt;&#x2F;select&gt;</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &lt;!-- 提交:使用submit类型,form表单提交必须使用submit按钮 --&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">                    &lt;!-- 重置:使用reset类型,可以把表单内容清空 --&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;重置&quot;&gt;</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;form&gt; </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML--语法结构</title>
    <url>/post/62ea55d8.html</url>
    <content><![CDATA[<h1 id="html–语法结构"><a href="#html–语法结构" class="headerlink" title="html–语法结构"></a>html–语法结构</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>超文本标记语言(Hyper Text Markup Language)，HTML 不是一种编程语言，而是一种 指超文本标签语言，是网页制作所必备的.</p>
<a id="more"></a>
<h2 id="html语法结构"><a href="#html语法结构" class="headerlink" title="html语法结构"></a>html语法结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  &lt;!--html的文档声明,声明当前html文档的版本--&gt;</span><br><span class="line">&lt;html&gt;           &lt;!--根标签: html开始标签 --&gt;</span><br><span class="line">    &lt;head&gt;       &lt;!--html标签中的第一个子标签: head开始标签--&gt;</span><br><span class="line">        &lt;!--单个标签meta: 主要用于当前文档设置, 这里设置的是文档的编码格式 utf-8--&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;   </span><br><span class="line">        &lt;!--单个标签meta: 视口,移动端内容进行自动适配--&gt;</span><br><span class="line">        &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">        &lt;!--单个标签meta: 如果是ie浏览器,让 IE 以最高版本显示网页--&gt;</span><br><span class="line">        &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">        &lt;title&gt;网页标题&lt;&#x2F;title&gt;   &lt;!--title标签: 主要用于设置当前文档标题--&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;      &lt;!--html标签中的第一个子标签: head结束标签--&gt;</span><br><span class="line">    &lt;body&gt;       &lt;!--html标签中的第二个子标签: body开始标签--&gt;</span><br><span class="line">        网页内容</span><br><span class="line">    &lt;&#x2F;body&gt;      &lt;!--html标签中的第二个子标签: body结束标签--&gt;</span><br><span class="line">&lt;&#x2F;html&gt;          &lt;!--根标签: html结束标签 --&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码就是<code>html</code>的基本结构,需要注意的是:<code>第七行</code>和<code>第九行</code><br>第七行:进行简单的移动端自动适配<br>第九行: 如果访问client使用的是<code>ie</code>浏览器的话,以最高版本进行显示网页</p>
</blockquote>
<h2 id="结构说明"><a href="#结构说明" class="headerlink" title="结构说明:"></a>结构说明:</h2><ul>
<li>html网页第一行<!DOCTYPE html>是文档声明, 用来指定页面所使用的html的版本, 这里声明的是一个html5的文档。</li>
<li>html一个网页包含两部分一部分是head,另一部分是body</li>
<li>head标签的主要作用:网页的设置和资源的引用,head标签中的内容一般不会显示在网页上</li>
<li> body中的内容通常用于网页显示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; (文档声明)</span><br><span class="line">	&lt;html&gt;(标志着html语言开始)</span><br><span class="line">		&lt;head&gt;(html的头部开始位置,一般放css和js声明,双标签格式)</span><br><span class="line">		&lt;&#x2F;head&gt;(html的头部结束位置)</span><br><span class="line">		&lt;body&gt;(页面展示开始位置,就是访问页面所能看到的资源都放在这个body里面)</span><br><span class="line">		&lt;&#x2F;body&gt;(页面展示结束位置)</span><br><span class="line">	&lt;&#x2F;html&gt;(标志着html语言结束)</span><br></pre></td></tr></table></figure>
<h2 id="html的单双标签"><a href="#html的单双标签" class="headerlink" title="html的单双标签"></a>html的单双标签</h2><blockquote>
<p>可以先看下下面的实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  &lt;!--html的文档声明,声明当前html文档的版本--&gt;</span><br><span class="line">&lt;html&gt;           &lt;!--根标签: html开始标签 --&gt;</span><br><span class="line">    &lt;head&gt;       &lt;!--html标签中的第一个子标签: head开始标签--&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;!--单个标签meta: 主要用于当前文档设置, 这里设置的是文档的编码格式 utf-8--&gt;</span><br><span class="line">        &lt;title&gt;网页标题&lt;&#x2F;title&gt;   &lt;!--title标签: 主要用于设置当前文档标题--&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;      &lt;!--html标签中的第一个子标签: head结束标签--&gt;</span><br><span class="line">    &lt;body&gt;       &lt;!--html标签中的第二个子标签: body开始标签--&gt;</span><br><span class="line">        网页内容</span><br><span class="line">    &lt;&#x2F;body&gt;      &lt;!--html标签中的第二个子标签: body结束标签--&gt;</span><br><span class="line">&lt;&#x2F;html&gt;          &lt;!--根标签: html结束标签 --&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;html&gt; &lt;head&gt; &lt;body&gt; &lt;title&gt; </code>这样的标签是成对的</li>
<li><code>&lt;meta&gt;</code> 这样的标签是单个的</li>
<li>标签是可以嵌套的: 例如 上面的代码中 html 标签, 嵌套了 head 标签和 body 标签.</li>
<li>单标签与双标签区别,单标签没有标签内容，双标签可以嵌套其它标签和承载文本内容</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux--Centos7 升级内核为最新长期维护版 4.4</title>
    <url>/post/45d64540.html</url>
    <content><![CDATA[<h1 id="Linux–Centos7-升级内核为最新长期维护版-4-4"><a href="#Linux–Centos7-升级内核为最新长期维护版-4-4" class="headerlink" title="Linux–Centos7 升级内核为最新长期维护版 4.4"></a>Linux–Centos7 升级内核为最新长期维护版 4.4</h1><h1 id="elrepo-官网"><a href="#elrepo-官网" class="headerlink" title="elrepo 官网"></a>elrepo 官网</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;elrepo.org</span><br><span class="line">https:&#x2F;&#x2F;elrepo.org&#x2F;tiki&#x2F;tiki-index.php</span><br></pre></td></tr></table></figure>
<h1 id="安装-ELRepo源"><a href="#安装-ELRepo源" class="headerlink" title="安装 ELRepo源"></a>安装 ELRepo源</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  查看内核</span><br><span class="line">[root@localhost ~]# uname -r</span><br><span class="line"></span><br><span class="line"># 安装 Yum密钥</span><br><span class="line">[root@localhost ~]# rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line"># 安装对应的Yum源</span><br><span class="line"># To install ELRepo for CentOS8</span><br><span class="line">yum install https:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-8.el8.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line"># To install ELRepo for CentOS7</span><br><span class="line">yum -y install yum-plugin-fastestmirror yum-utils</span><br><span class="line">yum install https:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.el7.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line"># To install ELRepo for CentO6</span><br><span class="line">yum -y install yum-plugin-fastestmirror yum-utils</span><br><span class="line">yum install https:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-6.el6.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure>
<h1 id="Centos7-安装内核"><a href="#Centos7-安装内核" class="headerlink" title="Centos7 安装内核"></a>Centos7 安装内核</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># list available 查看kernel的版本</span><br><span class="line">yum --disablerepo&#x3D;&quot;*&quot; --enablerepo&#x3D;&quot;elrepo-kernel&quot; </span><br><span class="line"></span><br><span class="line"># 安装秘钥</span><br><span class="line">rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line"># 安装最新长期维护版kernel</span><br><span class="line">yum -y --enablerepo&#x3D;elrepo-kernel install kernel-lt</span><br><span class="line"></span><br><span class="line"># 设置为默认为最新版本kernel</span><br><span class="line">grub2-set-default 0</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重启之后即可选择对应的内核版本</span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"># 查看当前系统所有的内核版本选择</span><br><span class="line">awk -F \&#39; &#39;$1&#x3D;&#x3D;&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#39; &#x2F;etc&#x2F;grub2.cfg</span><br><span class="line">        0 : CentOS Linux (3.10.0-1127.13.1.el7.x86_64) 7 (Core)</span><br><span class="line">        1 : CentOS Linux (4.4.228-2.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">        2 : CentOS Linux (3.10.0-1062.el7.x86_64) 7 (Core)</span><br><span class="line">        3 : CentOS Linux (0-rescue-fc3fb3f757784457a95f1652cd0c7f93) 7 (Core)</span><br><span class="line"></span><br><span class="line"># 设置默认启动的内核版本</span><br><span class="line">grub2-set-default &quot;CentOS Linux (4.4.228-2.el7.elrepo.x86_64) 7 (Core)&quot;</span><br><span class="line"># 或者执行如下步骤，上面和这个步骤是同样的效果</span><br><span class="line">grub2-set-default 1 (第二种方式，输入对应的内核编号)</span><br><span class="line"></span><br><span class="line"># 确认是否执行成功</span><br><span class="line">grub2-editenv list</span><br><span class="line">        saved_entry&#x3D;CentOS Linux (4.4.228-2.el7.elrepo.x86_64) 7 (Core)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM环境下制作CentOS7 qcow2格式镜像</title>
    <url>/post/38096.html</url>
    <content><![CDATA[<h1 id="KVM环境下制作CentOS7-qcow2格式镜像"><a href="#KVM环境下制作CentOS7-qcow2格式镜像" class="headerlink" title="KVM环境下制作CentOS7 qcow2格式镜像"></a>KVM环境下制作CentOS7 qcow2格式镜像</h1><p><code>virt-install</code>是一个命令行工具，它能够为KVM、Xen或其它支持libvirt API的hypervisor创建虚拟机并完成GuestOS安装；此外，它能够基于串行控制台、VNC或SDL支持文本或图形安装界面。安装过程可以使用本地的安装介质如CDROM，也可以通过网络方式如NFS、HTTP或FTP服务实现。对于通过网络安装的方式，virt-install可以自动加载必要的文件以启动安装过程而无须额外提供引导工具。当然，virt-install也支持PXE方式的安装过程，也能够直接使用现有的磁盘映像直接启动安装过程。</p>
<a id="more"></a>
<h2 id="宿主机环境配置"><a href="#宿主机环境配置" class="headerlink" title="宿主机环境配置"></a>宿主机环境配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;etc&#x2F;yum.repos.d&#x2F;bak </span><br><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;* &#x2F;etc&#x2F;yum.repos.d&#x2F;bak</span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">yum -y install wget vim</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br><span class="line">yum -y install qemu-kvm  qemu-img kvm qemu-kvm-tools libvirt  bridge-utils virt-*</span><br><span class="line"></span><br><span class="line"># 启动libvirtd</span><br><span class="line">systemctl enable libvirtd</span><br><span class="line">systemctl start libvirtd</span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line"># 关闭selinux</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#39;&#x2F;SELINUX&#x2F;s&#x2F;enforcing&#x2F;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line"># 设置时钟同步，并同步硬件时间</span><br><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai</span><br><span class="line">hwclock -w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改文件并发数及内核参数（可不调整）</span><br><span class="line">tee &#x2F;etc&#x2F;sysctl.conf &lt;&lt;-&#39;EOF&#39;</span><br><span class="line"># System default settings live in &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;00-system.conf.</span><br><span class="line"># To override those settings, enter new settings here, or in an &#x2F;etc&#x2F;sysctl.d&#x2F;&lt;name&gt;.conf file</span><br><span class="line">#</span><br><span class="line"># For more information, see sysctl.conf(5) and sysctl.d(5).</span><br><span class="line"></span><br><span class="line">net.ipv4.ip_local_port_range &#x3D; 10000 61000</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">net.core.netdev_max_backlog &#x3D; 2000</span><br><span class="line">net.ipv4.tcp_mem &#x3D; 131072  262144  524288</span><br><span class="line">net.ipv4.tcp_keepalive_intvl &#x3D; 30</span><br><span class="line">net.ipv4.tcp_keepalive_probes &#x3D; 3</span><br><span class="line">net.ipv4.tcp_window_scaling &#x3D; 1</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 2048</span><br><span class="line">net.ipv4.tcp_low_latency &#x3D; 0</span><br><span class="line">net.core.rmem_default &#x3D; 256960</span><br><span class="line">net.core.rmem_max &#x3D; 513920</span><br><span class="line">net.core.wmem_default &#x3D; 256960</span><br><span class="line">net.core.wmem_max &#x3D; 513920</span><br><span class="line">net.core.somaxconn &#x3D; 2048</span><br><span class="line">net.core.optmem_max &#x3D; 81920</span><br><span class="line">net.ipv4.tcp_mem &#x3D; 131072  262144  524288</span><br><span class="line">net.ipv4.tcp_rmem &#x3D; 8760  256960  4088000</span><br><span class="line">net.ipv4.tcp_wmem &#x3D; 8760  256960  4088000</span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 1800</span><br><span class="line">net.ipv4.tcp_sack &#x3D; 1</span><br><span class="line">net.ipv4.tcp_fack &#x3D; 1</span><br><span class="line">net.ipv4.tcp_timestamps &#x3D; 1</span><br><span class="line">net.ipv4.tcp_syn_retries &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-arptables &#x3D; 1</span><br><span class="line">fs.inotify.max_user_instances &#x3D; 8192</span><br><span class="line">fs.inotify.max_user_watches &#x3D; 1048576</span><br><span class="line">vm.max_map_count &#x3D; 262144</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>163的Centos7.8_2003的下载地址，就不隐藏了<br><a href="http://mirrors.163.com/centos/7.8.2003/isos/x86_64/CentOS-7-x86_64-DVD-2003.iso">http://mirrors.163.com/centos/7.8.2003/isos/x86_64/CentOS-7-x86_64-DVD-2003.iso</a></p>
<p>上传到所在的宿主机上，放在<code>/data/iso_image</code>目录下</p>
<h2 id="创建qcow2镜像文件"><a href="#创建qcow2镜像文件" class="headerlink" title="创建qcow2镜像文件"></a>创建qcow2镜像文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建成功很小的文件，只有真正写入数据的时候才会增长，最大为100G</span><br><span class="line">qemu-img create -f qcow2 &#x2F;data&#x2F;CentOS7_Base.qcow2 100G</span><br></pre></td></tr></table></figure>
<h2 id="创建kvm虚拟机"><a href="#创建kvm虚拟机" class="headerlink" title="创建kvm虚拟机"></a>创建kvm虚拟机</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">--name 指定虚机名字</span><br><span class="line">--ram  指定内存</span><br><span class="line">--vcpus 指定CPU数量</span><br><span class="line">--os-type 指定系统类型</span><br><span class="line">--os-variant 指定系统规格</span><br><span class="line">--arch 指定64位</span><br><span class="line">--network 指定网络类型（很重要，指定错误无法访问）</span><br><span class="line">--disk path qcow2的镜像位置</span><br><span class="line">--location 实际iso镜像位置</span><br><span class="line">--console 指定管理控制台类型</span><br><span class="line">--graphics 指定物理设备vnc连接地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">virt-install --name CentOS7_Base --ram 4096 --vcpus 4 --os-type linux --os-variant rhel7 --arch&#x3D;x86_64 --network network&#x3D;default,model&#x3D;virtio --disk path&#x3D;&#x2F;data&#x2F;CentOS7_Base.qcow2,format&#x3D;qcow2 --location &#x2F;data&#x2F;iso_image&#x2F;CentOS-7-x86_64-DVD-2003.iso --console pty,target_type&#x3D;serial   --graphics vnc,listen&#x3D;0.0.0.0,port&#x3D;7788</span><br></pre></td></tr></table></figure>
<p>上面的步骤安装完之后就需要直接连接上你正在创建的虚拟机上去操作了，这个时候你可以使用vncviewer或者ultravnc都行<br>我就直接上图了，就这个界面，我就不详细说了，图形化的操作比较简单，网卡可以配也可以后面配随便<br><img src="/images/kvm/KVM-tuxinghua.png" alt="KVM-tuxinghua"><br>操作之后，使用ssh连接上去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm-rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*</span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">yum -y install wget vim</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br><span class="line"></span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"></span><br><span class="line"># 关闭selinux</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#39;&#x2F;SELINUX&#x2F;s&#x2F;enforcing&#x2F;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line"># 设置时钟同步，并同步硬件时间</span><br><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai</span><br><span class="line">hwclock -w</span><br></pre></td></tr></table></figure>
<h2 id="故障不能连接请看这里"><a href="#故障不能连接请看这里" class="headerlink" title="故障不能连接请看这里"></a>故障不能连接请看这里</h2><p>如果不能连ssh可能是你的网卡配置有问题，可以直接到<code>/etc/libvirt/qemu</code>找到上面<code>name</code>相同的xml文件编辑下。主要修改类型<code>type=&#39;bridge&#39;、bridge=&#39;br0、type=&#39;virtio&#39;</code> 确认网卡关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;interface type&#x3D;&#39;bridge&#39;&gt;</span><br><span class="line">  &lt;mac address&#x3D;&#39;52:54:00:39:dd:20&#39;&#x2F;&gt;</span><br><span class="line">  &lt;source bridge&#x3D;&#39;br0&#39;&#x2F;&gt;</span><br><span class="line">  &lt;model type&#x3D;&#39;virtio&#39;&#x2F;&gt;</span><br><span class="line">  &lt;address type&#x3D;&#39;pci&#39; domain&#x3D;&#39;0x0000&#39; bus&#x3D;&#39;0x00&#39; slot&#x3D;&#39;0x03&#39; function&#x3D;&#39;0x0&#39;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;interface&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux--LVS构建keepalive高可用站点</title>
    <url>/post/279cd39e.html</url>
    <content><![CDATA[<h1 id="实验设备：4台相同版本服务器"><a href="#实验设备：4台相同版本服务器" class="headerlink" title="实验设备：4台相同版本服务器"></a>实验设备：4台相同版本服务器</h1><h1 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h1><pre><code>iptables -F
setenforce 0
</code></pre>
<h1 id="实验说明："><a href="#实验说明：" class="headerlink" title="实验说明："></a>实验说明：</h1><p>webserver 1：192.168.192.138<br>webserver 2：192.168.192.106<br>lesserver 1：192.168.192.106<br>lvsserver 2：192.168.192.105</p>
<a id="more"></a>
<h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="1-构建webserver服务"><a href="#1-构建webserver服务" class="headerlink" title="1.构建webserver服务"></a>1.构建webserver服务</h2><p>安装web服务nginx或者httpd,两台webserver都安装</p>
<pre><code>yum -y install nginx
echo &quot;web1&quot;&gt;/usr/share/nginx/html/index.html
echo &quot;web2&quot;&gt;/usr/share/nginx/html/index.html
systemctl start nginx
</code></pre>
<h2 id="修改内核参数arp"><a href="#修改内核参数arp" class="headerlink" title="修改内核参数arp"></a>修改内核参数arp</h2><p>写脚本进行修改，同时指明vip（virtual server IP）</p>
<pre><code>vim arp.sh
#!/bin/bash
vip=192.168.192.11
mask=&#39;255.255.255.255&#39;
case $1 in
start)
echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore
echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce
echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce
ifconfig lo:0 $vip netmask $mask broadcast $vip up
route add -host $vip dev lo:0
;;
stop)
ifconfig lo:0 down
echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore
echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_announce
echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce
;;
*)
echo &quot;Usage $(basename $0) start|stop&quot;
exit 1
;;
esac
</code></pre>
<p>复制两份分别在两台webserver上执行</p>
<pre><code>bash arp.sh start
</code></pre>
<h2 id="构建lvs"><a href="#构建lvs" class="headerlink" title="构建lvs"></a>构建lvs</h2><p>分别在两台lvsserver上安装lvs</p>
<pre><code>yum -y install ipvsadm
vim lvs.sh
#!/bin/bash
vip=&#39;192.168.192.11&#39;
iface=&#39;ens32:0&#39;
mask=&#39;255.255.255.255&#39;
port=&#39;80&#39;
rs1=&#39;192.168.192.106&#39;
rs2=&#39;192.168.192.138&#39;
scheduler=&#39;rr&#39;
type=&#39;-g&#39;
case $1 in
start)
ifconfig $iface $vip netmask $mask broadcast $vip up
iptables -F
ipvsadm -A -t $&#123;vip&#125;:$&#123;port&#125; -s $scheduler
ipvsadm -a -t $&#123;vip&#125;:$&#123;port&#125; -r $&#123;rs1&#125; $type
ipvsadm -a -t $&#123;vip&#125;:$&#123;port&#125; -r $&#123;rs2&#125; $type
;;
stop)
ipvsadm -C
ifconfig $iface down
;;
*)
echo &quot;Usage $(basename $0) start|stop“;exit 1&quot;
;;
esac
</code></pre>
<p>ipvs.sh脚本两台lvsserver都要执行</p>
<h1 id="构建keepalive-单主模型，会出现单点失败"><a href="#构建keepalive-单主模型，会出现单点失败" class="headerlink" title="构建keepalive(单主模型，会出现单点失败)"></a>构建keepalive(单主模型，会出现单点失败)</h1><pre><code>vim /etc/keepalived/keepalived.conf
! Configuration File for keepalived

global_defs &#123;
   notification_email &#123;
     root@localhost
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1（邮件服务器地址）
   smtp_connect_timeout 30（邮件服务器连接市场）
   router_id LVS_DEVEL
   vrrp_mcast_group4 224.26.100.19 （发送组播地址，判断vrrp是否成功获取地址）
&#125;

vrrp_instance VI_1 &#123;
    state MASTER
    interface ens32
    virtual_router_id 50
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
        192.168.192.11
    &#125;
&#125;

    virtual_server 192.168.192.11 80 &#123;
        delay_loop 1
        lb_algo rr
        lb_kind DR
        protocol TCP
        sorry_server 127.0.0.1 80（添加sorry）

    real_server 192.168.192.105 80 &#123;
        weight 1 （权重）
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200（状态相应码为check信息）
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
    &#125;
    real_server 192.168.192.138 80 &#123;
        weight 1
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
&#125;
在lvsserver2上配置
    vim /etc/keepalived/keepalived.conf
! Configuration File for keepalived

global_defs &#123;
   notification_email &#123;
     root@localhost
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1（邮件服务器地址）
   smtp_connect_timeout 30（邮件服务器连接市场）
   router_id LVS_DEVEL
   vrrp_mcast_group4 224.26.100.19 （发送组播地址，判断vrrp是否成功获取地址）
&#125;

vrrp_instance VI_1 &#123;
    state BACKUP
    interface ens32
    virtual_router_id 50
    priority 99
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
        192.168.192.11
    &#125;
&#125;

    virtual_server 192.168.192.11 80 &#123;
        delay_loop 1
        lb_algo rr
        lb_kind DR
        protocol TCP
        sorry_server 127.0.0.1 80（添加sorry）

    real_server 192.168.192.105 80 &#123;
        weight 1 （权重）
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200（状态相应码为check信息）
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
    &#125;
    real_server 192.168.192.138 80 &#123;
        weight 1
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
&#125;
</code></pre>
<h2 id="双主模型"><a href="#双主模型" class="headerlink" title="双主模型"></a>双主模型</h2><p>在lvsserver1上配置</p>
<pre><code>vim /etc/keepalived/keepalived.conf
! Configuration File for keepalived

global_defs &#123;
   notification_email &#123;
     root@localhost
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1（邮件服务器地址）
   smtp_connect_timeout 30（邮件服务器连接市场）
   router_id LVS_DEVEL
   vrrp_mcast_group4 224.26.100.19 （发送组播地址，判断vrrp是否成功获取地址）
&#125;

vrrp_instance VI_1 &#123;
    state MASTER
    interface ens32
    virtual_router_id 50
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
        192.168.192.11
    &#125;
&#125;
    vrrp_instance VI_2 &#123;
    state BACKUP
    interface ens32
    virtual_router_id 51
    priority 95
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 2222
    &#125;
    virtual_ipaddress &#123;
        192.168.192.22
    &#125;
track_interface &#123;
        ens32
        &#125;
        notify_master &quot;/etc/keepalived/notify.sh master&quot;
        notify_backup &quot;/etc/keepalived/notify.sh backup&quot;
        notify_fault &quot;/etc/keepalived/notify.sh fault&quot;
        &#125;
&#125;

    virtual_server 192.168.192.11 80 &#123;
        delay_loop 1
        lb_algo rr
        lb_kind DR
        protocol TCP
        sorry_server 127.0.0.1 80（添加sorry）

    real_server 192.168.192.105 80 &#123;
        weight 1 （权重）
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200（状态相应码为check信息）
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
    &#125;
    real_server 192.168.192.138 80 &#123;
        weight 1
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
&#125;
</code></pre>
<p>在lvsserver2上配置</p>
<pre><code>vim /etc/keepalived/keepalived.conf
! Configuration File for keepalived

global_defs &#123;
   notification_email &#123;
     root@localhost
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1（邮件服务器地址）
   smtp_connect_timeout 30（邮件服务器连接市场）
   router_id LVS_DEVEL
   vrrp_mcast_group4 224.26.100.19 （发送组播地址，判断vrrp是否成功获取地址）
&#125;

vrrp_instance VI_1 &#123;
    state BACKUP
    interface ens32
    virtual_router_id 50
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
        192.168.192.11
    &#125;
&#125;
    vrrp_instance VI_2 &#123;
    state MASTER
    interface ens32
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 2222
    &#125;
    virtual_ipaddress &#123;
        192.168.192.22
    &#125;
track_interface &#123;
        ens32
        &#125;
        notify_master &quot;/etc/keepalived/notify.sh master&quot;
        notify_backup &quot;/etc/keepalived/notify.sh backup&quot;
        notify_fault &quot;/etc/keepalived/notify.sh fault&quot;
        &#125;
&#125;

    virtual_server 192.168.192.11 80 &#123;
        delay_loop 1
        lb_algo rr
        lb_kind DR
        protocol TCP
        sorry_server 127.0.0.1 80（添加sorry）

    real_server 192.168.192.105 80 &#123;
        weight 1 （权重）
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200（状态相应码为check信息）
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
    &#125;
    real_server 192.168.192.138 80 &#123;
        weight 1
        HTTP_GET &#123;
            url &#123;
              path /
                status_code 200
            &#125;
            &#125;
            connect_timeout 1
            nb_get_retry 1
            delay_before_retry 3
        &#125;
&#125;
</code></pre>
<h1 id="通知脚本"><a href="#通知脚本" class="headerlink" title="通知脚本"></a>通知脚本</h1><pre><code>#!/bin/bash
contact=&#39;root@localhost&#39;
notify() &#123;
    local mailsubject=&quot;$(hostname) to be $1, vip floating&quot;
    local mailbody=&quot;$(date +&#39;%F %T&#39;): vrrp transition, $(hostname) changed to be $1&quot;
    echo &quot;$mailbody&quot; | mail -s &quot;$mailsubject&quot; $contact
&#125;
case $1 in
master)
        notify master
        ;;      
backup)
        notify backup
;;
fault)
        notify fault
;;
*)        echo &quot;Usage: $(basename $0) &#123;master|backup|fault&#125;&quot;
        exit 1
;;
esac
</code></pre>
<p>这个脚本上面在配置文件中已经进行调用，这里不再解释。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux--LVS简介</title>
    <url>/post/27b68446.html</url>
    <content><![CDATA[<h1 id="LVS的简单介绍"><a href="#LVS的简单介绍" class="headerlink" title="LVS的简单介绍"></a>LVS的简单介绍</h1><p>LVS：Linux Virtual Server，负载调度器，集成内核<br>官网：<a href="http://www.linuxvirtualserver.org/">http://www.linuxvirtualserver.org/</a><br>VS: Virtual Server，负责调度<br>RS: Real Server，负责真正提供服务<br>L4：四层路由器或交换机<br>工作原理：VS根据请求报文的目标IP和目标协议及端口将其调度转发至某RS，根据调度算法来挑选RS</p>
<a id="more"></a>

<h2 id="LVS集群体系结构"><a href="#LVS集群体系结构" class="headerlink" title="LVS集群体系结构"></a>LVS集群体系结构</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503221835043&di=47414add666203e111086acf5043a2e8&imgtype=jpg&src=http://h.hiphotos.baidu.com/image/pic/item/8b13632762d0f7032e7ac40402fa513d2797c51a.jpg"><br>lvs集群类型中的术语：<br>VS：Virtual Server，Director，Dispatcher(调度器)，Load Balancer<br>RS：Real Server(lvs), upstream server(nginx)，backend server(haproxy)<br>CIP：Client IP<br>VIP: Virtual serve IP        VS外网的IP<br>DIP: Director IP            VS内网的IP<br>RIP: Real server IP<br>访问流程：CIP &lt;–&gt; VIP == DIP &lt;–&gt; RIP</p>
<p>lvs集群的类型：<br>lvs-nat：修改请求报文的目标IP,多目标IP的DNAT<br>lvs-dr：操纵封装新的MAC地址<br>lvs-tun：在原请求IP报文之外新加一个IP首部<br>lvs-fullnat：修改请求报文的源和目标IP</p>
<h1 id="lvs-nat"><a href="#lvs-nat" class="headerlink" title="lvs-nat"></a>lvs-nat</h1><p>本质是多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发<br>（1）RIP和DIP必须在同一个IP网络，且应该使用私网地址；RS的网关要指向DIP<br>（2）请求报文和响应报文都必须经由Director转发，Director易于成为系统瓶颈<br>（3）支持端口映射，可修改请求报文的目标PORT<br>（4）VS必须是Linux系统，RS可以是任意OS系统<br>NAT模式下的简单体系结构<br><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503222191386&di=720a59f17978b4890d760a64a2f2ad85&imgtype=jpg&src=http://f.hiphotos.baidu.com/image/pic/item/f9dcd100baa1cd11270c21f8b312c8fcc2ce2dab.jpg"></p>
<p>NAT模式IP包调度过程</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503222267728&di=da68727c95ebea4ffe70c7257e8334e4&imgtype=jpg&src=http://h.hiphotos.baidu.com/image/pic/item/a6efce1b9d16fdfab0ed9536be8f8c5495ee7b60.jpg"></p>
<h1 id="LVS-DR"><a href="#LVS-DR" class="headerlink" title="LVS-DR"></a>LVS-DR</h1><p>Direct Routing，直接路由，LVS默认模式,应用最广泛通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变.其中</p>
<h2 id="Director和各RS都配置有VIP"><a href="#Director和各RS都配置有VIP" class="headerlink" title="Director和各RS都配置有VIP"></a>Director和各RS都配置有VIP</h2><pre><code>- (1) 确保前端路由器将目标IP为VIP的请求报文发往Director
    - (a) 在前端网关做静态绑定VIP和Director的MAC地址
    - (b) 在RS上使用arptables工具
    - (c) 在RS上修改内核参数以限制arp通告及应答级别
        - arp_announce
        - arp_ignore
- (2) RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；RIP的网关不能指向DIP，以确保响应报文不会经由Director
- (3) RS和Director要在同一个物理网络
- (4) 请求报文要经由Director，但响应报文不经由Director，而由RS直接发往Client
- (5) 不支持端口映射（端口不能修败）
- (6) RS可使用大多数OS系统
</code></pre>
<p>VS/DR体系结构</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503222567415&di=f21266919b5fc52bf4e70b9237e0df99&imgtype=jpg&src=http://g.hiphotos.baidu.com/image/pic/item/ac345982b2b7d0a2f2f15945c1ef76094b369a2a.jpg"></p>
<p>DR模式IP包调度过程</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503222621685&di=ffe27a3eab4bedd12175885cdf1a6b2b&imgtype=jpg&src=http://g.hiphotos.baidu.com/image/pic/item/86d6277f9e2f07088e5677d8e324b899a801f293.jpg"></p>
<h1 id="lvs-tun模式"><a href="#lvs-tun模式" class="headerlink" title="lvs-tun模式"></a>lvs-tun模式</h1><p>转发方式：不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而在原IP报文之外再封装一个IP首部（源IP是DIP，目标IP是RIP），将报文发往挑选出的目标RS；RS直接响应给客户端（源IP是VIP，目标IP是CIP）<br>(1) DIP, VIP, RIP都应该是公网地址<br>(2) RS的网关不能，也不可能指向DIP<br>(3) 请求报文要经由Director，但响应不能经由Director<br>(4) 不支持端口映射<br>(5) RS的OS须支持隧道功能</p>
<p>VS/TUN体系结构<br><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503222737686&di=1487a8e8d96772401819b46210f284f8&imgtype=jpg&src=http://a.hiphotos.baidu.com/image/pic/item/0df3d7ca7bcb0a46223dd7e16163f6246a60afcf.jpg"></p>
<p>TUN模式IP包调度过程</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503222784873&di=d4f9dbc89892bb279d0c65ac265fc8a0&imgtype=jpg&src=http://a.hiphotos.baidu.com/image/pic/item/3812b31bb051f8191e495f92d0b44aed2f73e7fe.jpg"></p>
<h1 id="lvs-fullnat模式"><a href="#lvs-fullnat模式" class="headerlink" title="lvs-fullnat模式"></a>lvs-fullnat模式</h1><p>lvs-fullnat：通过同时修改请求报文的源IP地址和目标IP地址进行转发<br>    CIP –&gt; DIP<br>    VIP –&gt; RIP<br>(1) VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此，RIP的网关一般不会指向DIP<br>(2) RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client<br>(3) 请求和响应报文都经由Director<br>(4) 支持端口映射；<br>注意：此类型kernel默认不支持</p>
<h1 id="VS工作模式总结"><a href="#VS工作模式总结" class="headerlink" title="VS工作模式总结"></a>VS工作模式总结</h1><p>lvs-nat, lvs-fullnat：请求和响应报文都经由Director<br>lvs-nat：RIP的网关要指向DIP<br>lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信<br>lvs-dr, lvs-tun：请求报文要经由Director，但响应报文由RS直接发往Client<br>lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发<br>lvs-tun：通过在原IP报文之外封装新的IP报文实现转发，支持远距离通信</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1503222936092&di=27b0dc0d9fb51d4c89c8af63019b2d41&imgtype=jpg&src=http://d.hiphotos.baidu.com/image/pic/item/c2fdfc039245d6888f91ee7caec27d1ed31b2452.jpg"></p>
<h1 id="ipvs-scheduler"><a href="#ipvs-scheduler" class="headerlink" title="ipvs scheduler"></a>ipvs scheduler</h1><p>根据其调度时是否考虑各RS当前的负载状态<code>动态</code>和<code>静态</code></p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>静态方法：仅根据算法本身进行调度<br>1、RR：roundrobin，轮询<br>2、WRR：Weighted RR，加权轮询<br>3、SH：Source Hashing，实现session sticky，源IP地址hash；将来自于同一个IP地址的请求始终发往第一次挑中的RS，从而实现会话绑定<br>4、DH：Destination Hashing；目标地址哈希，将发往同一个目标地址的请求始终转发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡，如：宽带运营商</p>
<h2 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h2><p>动态方法：主要根据每RS当前的负载状态及调度算法进行调度Overhead=value较小的RS将被调度<br>1、LC：least connections<br>Overhead=activeconns<em>256+inactiveconns<br>2、WLC：Weighted LC，默认调度方法<br>Overhead=(activeconns</em>256+inactiveconns)/weight<br>3、SED：Shortest Expection Delay,解决初始连接的问题<br>Overhead=(activeconns+1)*256/weight<br>4、NQ：Never Queue，第一轮均匀分配，后续SED<br>5、LBLC：Locality-Based LC，动态的DH算法，使用场景：根据负载状态实现正向代理<br>6、LBLCR：LBLC with Replication，带复制功能的LBLC</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux--sed获取指定时间段日志.md</title>
    <url>/post/33e57216.html</url>
    <content><![CDATA[<h1 id="sed的简单使用"><a href="#sed的简单使用" class="headerlink" title="sed的简单使用"></a>sed的简单使用</h1><h2 id="删除指定字符行"><a href="#删除指定字符行" class="headerlink" title="删除指定字符行"></a>删除指定字符行</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除以a开头的行</span><br><span class="line">[root@vm14 home]# cat test</span><br><span class="line">1111</span><br><span class="line">qqqq</span><br><span class="line">aaaa</span><br><span class="line">bbbb</span><br><span class="line">cccc</span><br><span class="line">2222</span><br><span class="line">[root@vm14 home]# sed -i &#39;&#x2F;^a&#x2F;d&#39; test</span><br><span class="line">[root@vm14 home]# cat test</span><br><span class="line">1111</span><br><span class="line">qqqq</span><br><span class="line">bbbb</span><br><span class="line">cccc</span><br><span class="line">2222</span><br><span class="line">#删除包含a的行，尽量不要这样子操作，只要内容中包含都会删除掉，除非你确定</span><br><span class="line">[root@vm14 home]# cat test</span><br><span class="line">1111</span><br><span class="line">qqqq</span><br><span class="line">aaaa</span><br><span class="line">bbba</span><br><span class="line">cccc</span><br><span class="line">2222</span><br><span class="line">[root@vm14 home]# sed -i &#39;&#x2F;a&#x2F;d&#39; test</span><br><span class="line">[root@vm14 home]# cat test</span><br><span class="line">1111</span><br><span class="line">qqqq</span><br><span class="line">cccc</span><br><span class="line">2222</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除以)开头的行的上一行末尾的逗号,用在sql上大部分</span><br><span class="line">[root@vm14 home]# cat test</span><br><span class="line">CREATE TABLE test1 (</span><br><span class="line">  ID number(11) ,</span><br><span class="line">  name varchar2(32) ,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE test2 (</span><br><span class="line">  ID number(11) ,</span><br><span class="line">  name varchar2(32) ,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE test3 (</span><br><span class="line">  ID number(11) ,</span><br><span class="line">  name varchar2(32) ,</span><br><span class="line">);</span><br><span class="line">[root@vm14 home]# sed &#39;&#x2F;,\s*$&#x2F;&#123;:loop; N; &#x2F;,\(\s*\|\n\))&#x2F;! bloop; s&#x2F;,\s*[\n]\?\s*)&#x2F;\n)&#x2F;&#125;&#39; test</span><br><span class="line">CREATE TABLE test1 (</span><br><span class="line">  ID number(11) ,</span><br><span class="line">  name varchar2(32)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE test2 (</span><br><span class="line">  ID number(11) ,</span><br><span class="line">  name varchar2(32)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE test3 (</span><br><span class="line">  ID number(11) ,</span><br><span class="line">  name varchar2(32)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="截取日志"><a href="#截取日志" class="headerlink" title="截取日志"></a>截取日志</h2><p>首先生成类似日志文件格式的测试文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in &#96;seq 1 24&#96;  </span><br><span class="line">do  </span><br><span class="line">   for j in &#96;seq 1 60&#96;  </span><br><span class="line">	do  </span><br><span class="line">	    echo &quot;2020-08-11 $i:$j [http-nio-8080-exec-15] INFO&quot; &gt;&gt;test</span><br><span class="line">	done  </span><br><span class="line">done  </span><br><span class="line"># 生成的文件，大概就这样，日期加上时间，差不多就这样</span><br><span class="line">cat test</span><br><span class="line">2020-08-11 1:1 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:2 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:3 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:4 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:5 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:6 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:7 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:8 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:9 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:10 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:11 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:12 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:13 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:14 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:15 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:16 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:17 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:18 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:19 [http-nio-8080-exec-15] INFO</span><br><span class="line">2020-08-11 1:20 [http-nio-8080-exec-15] INFO</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>使用<code>sed</code>进行截取，一般日期时间都是放到最前面的，这个是运维必须的规范，如果不是，请告知研发修改日志输出格式，或者自己修改日志配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 截取凌晨21点到22点的日志</span><br><span class="line"># 格式   sed  -n 时间段  源文件 &gt; 生成的文件 千万要加上^，否则会将段内有匹配的也筛出来</span><br><span class="line">sed -n &#39;&#x2F;^2020-08-11 21&#x2F;,&#x2F;^2020-08-11 22&#x2F;p&#39; test &gt;test1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一键安装ss</title>
    <url>/post/6ab12166.html</url>
    <content><![CDATA[<p>一键安装sss<br>这个是ss的下载链接，因为是从国外下载的所以比较慢，高版本和低版本没什么区别，都可以用。<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/4.1.1/Shadowsocks-4.1.1.zip">下载链接</a></p>
<a id="more"></a>

<p>环境要求：</p>
<ul>
<li>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+</li>
<li>内存要求：≥128M</li>
</ul>
<p>默认配置</p>
<ul>
<li>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）</li>
<li>密码：自己设定（如不设定，默认为 teddysun.com）</li>
<li>加密方式：自己设定（如不设定，Python 和 libev 版默认为 aes-256-gcm，R 和 Go 版默认为 aes-256-cfb）</li>
<li>协议（protocol）：自己设定（如不设定，默认为 origin）（仅限 ShadowsocksR 版）</li>
<li>混淆（obfs）：自己设定（如不设定，默认为 plain）（仅限 ShadowsocksR 版）</li>
<li>备注：脚本默认创建单用户配置文件，如需配置多用户，请手动修改相应的配置文件后重启即可。</li>
</ul>
<p>使用root用户登录，运行以下命令：</p>
<pre><code>wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh
chmod +x shadowsocks-all.sh
./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log
</code></pre>
<p>安装完成后，脚本提示如下</p>
<pre><code>Congratulations, your_shadowsocks_version install completed!
Your Server IP        :your_server_ip
Your Server Port      :your_server_port
Your Password         :your_password
Your Encryption Method:your_encryption_method

Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)
 ss://your_encryption_method:your_password@your_server_ip:your_server_port
Your QR Code has been saved as a PNG file path:
 your_path.png

Enjoy it!
</code></pre>
<p>卸载方法</p>
<p>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）</p>
<p>使用root用户登录，运行以下命令：</p>
<pre><code>./shadowsocks-all.sh uninstall
</code></pre>
<p>启动脚本</p>
<p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>
<p>Shadowsocks-Python 版：</p>
<pre><code>/etc/init.d/shadowsocks-python start | stop | restart | status
</code></pre>
<p>ShadowsocksR 版：</p>
<pre><code>/etc/init.d/shadowsocks-r start | stop | restart | status
</code></pre>
<p>Shadowsocks-Go 版：</p>
<pre><code>/etc/init.d/shadowsocks-go start | stop | restart | status
</code></pre>
<p>Shadowsocks-libev 版：</p>
<pre><code>/etc/init.d/shadowsocks-libev start | stop | restart | status
</code></pre>
<p>各版本默认配置文件</p>
<p>Shadowsocks-Python 版：</p>
<pre><code>/etc/shadowsocks-python/config.json
</code></pre>
<p>ShadowsocksR 版：</p>
<pre><code>/etc/shadowsocks-r/config.json
</code></pre>
<p>Shadowsocks-Go 版：</p>
<pre><code>/etc/shadowsocks-go/config.json
</code></pre>
<p>Shadowsocks-libev 版：</p>
<pre><code>/etc/shadowsocks-libev/config.json
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-MySQL密码强度设置</title>
    <url>/post/27b68446.html</url>
    <content><![CDATA[<h1 id="Linux-MySQL密码强度设置"><a href="#Linux-MySQL密码强度设置" class="headerlink" title="Linux-MySQL密码强度设置"></a>Linux-MySQL密码强度设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;</span><br><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requiremen</span><br></pre></td></tr></table></figure>
<p>MySQL在5.6.6版本之后增加了密码强度验证插件validate_password相对来说比较严格。<br>如果不满足对应的密码强度,会提示错误,拒绝执行.</p>
<h1 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看mysql全局参数配置</span><br><span class="line">mysql&gt; select @@validate_password_policy;  </span><br><span class="line">+----------------------------+  </span><br><span class="line">| @@validate_password_policy |  </span><br><span class="line">+----------------------------+  </span><br><span class="line">| MEDIUM                     |  </span><br><span class="line">+----------------------------+  </span><br><span class="line">1 row in set (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;  </span><br><span class="line">+--------------------------------------+--------+  </span><br><span class="line">| Variable_name                        | Value  |  </span><br><span class="line">+--------------------------------------+--------+  </span><br><span class="line">| validate_password_dictionary_file    |        |  </span><br><span class="line">| validate_password_length             | 8      |  </span><br><span class="line">| validate_password_mixed_case_count   | 1      |  </span><br><span class="line">| validate_password_number_count       | 1      |  </span><br><span class="line">| validate_password_policy             | MEDIUM |  </span><br><span class="line">| validate_password_special_char_count | 1      |  </span><br><span class="line">+--------------------------------------+--------+  </span><br><span class="line">6 rows in set (0.08 sec) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">validate_password_dictionary_file</span><br><span class="line">插件用于验证密码强度的字典文件路径。</span><br><span class="line"></span><br><span class="line">validate_password_length</span><br><span class="line">密码最小长度，参数默认为8，它有最小值的限制，最小值为：validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count)</span><br><span class="line"></span><br><span class="line">validate_password_mixed_case_count</span><br><span class="line">密码至少要包含的小写字母个数和大写字母个数。</span><br><span class="line"></span><br><span class="line">validate_password_number_count</span><br><span class="line">密码至少要包含的数字个数。</span><br><span class="line"></span><br><span class="line">validate_password_policy</span><br><span class="line">密码强度检查等级，0&#x2F;LOW、1&#x2F;MEDIUM、2&#x2F;STRONG。有以下取值：</span><br><span class="line">Policy                 Tests Performed                                                                                                        </span><br><span class="line">0 or LOW               Length                                                                                                                      </span><br><span class="line">1 or MEDIUM         Length; numeric, lowercase&#x2F;uppercase, and special characters                             </span><br><span class="line">2 or STRONG        Length; numeric, lowercase&#x2F;uppercase, and special characters; dictionary file      </span><br><span class="line">默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。</span><br><span class="line"></span><br><span class="line">validate_password_special_char_count</span><br><span class="line">密码至少要包含的特殊字符数。</span><br></pre></td></tr></table></figure>
<h1 id="修改mysql参数配置"><a href="#修改mysql参数配置" class="headerlink" title="修改mysql参数配置"></a>修改mysql参数配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy&#x3D;0;  </span><br><span class="line">Query OK, 0 rows affected (0.05 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt;   </span><br><span class="line">mysql&gt;   </span><br><span class="line">mysql&gt; set global validate_password_mixed_case_count&#x3D;0;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; set global validate_password_number_count&#x3D;3;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; set global validate_password_special_char_count&#x3D;0;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; set global validate_password_length&#x3D;3;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;  </span><br><span class="line">+--------------------------------------+-------+  </span><br><span class="line">| Variable_name                        | Value |  </span><br><span class="line">+--------------------------------------+-------+  </span><br><span class="line">| validate_password_dictionary_file    |       |  </span><br><span class="line">| validate_password_length             | 3     |  </span><br><span class="line">| validate_password_mixed_case_count   | 0     |  </span><br><span class="line">| validate_password_number_count       | 3     |  </span><br><span class="line">| validate_password_policy             | LOW   |  </span><br><span class="line">| validate_password_special_char_count | 0     |  </span><br><span class="line">+--------------------------------------+-------+  </span><br><span class="line">6 rows in set (0.00 sec)  </span><br></pre></td></tr></table></figure>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;123&#39;);  </span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础--shell测试</title>
    <url>/post/96e941a9.html</url>
    <content><![CDATA[<h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><h2 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h2><pre><code>1 与 与 1 = 1
1 与 与 0 = 0
0 与 与 1 = 0
0 与 与 0 = 0
</code></pre>
<h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h2><pre><code>1 或 或 1 = 1
1 或 或 0 = 1
0 或 或 1 = 1
0 或 或 0 = 0
</code></pre>
<h2 id="非运算"><a href="#非运算" class="headerlink" title="非运算 !"></a>非运算 !</h2><pre><code>! 1 = 0
! 0 = 1
</code></pre>
<a id="more"></a>
<h2 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h2><h3 id="短路与"><a href="#短路与" class="headerlink" title="短路与"></a>短路与</h3><p><code>&amp;&amp; </code> 代表条件性的AND THEN</p>
<ul>
<li><p> 第一个为0 ，结果必定为0</p>
</li>
<li><p>第一个为1 ，第二个必须要参与运算</p>
<h3 id="短路或"><a href="#短路或" class="headerlink" title="短路或"></a>短路或</h3><p><code>|| </code>代表条件性的OR ELSE</p>
<ul>
<li><p>第一个为1 ，结果必定为1</p>
</li>
<li><p>第一个为0 ，第二个必须要参与运算<br><code>异或：^</code><br>异或的两个值, 相同为假，不同为真</p>
<p>grep -q no_such_user /etc/passwd || echo ‘No such user’<br>ping -c1 -W2 station1 &amp;&gt; /dev/null&amp;&amp; echo “station1 is up” || (echo ‘station1 is unreachable’; exit 1)<br>#利用 test 指令的测试功能<br>当我要检测系统上面某些文件或者是相关的属性时，利用 test 这个指令， 举例来说，我要检查 /testfile 文件是否存在时，使用：</p>
</li>
</ul>
<p>test -e /testfile<br>执行结果并不会显示任何讯息，但最后我们可以通过 $? 或 &amp;&amp; 及 || 来展现整个结果呢！ 例如我们在将上面的例子改写成这样：</p>
<p>test -e /testfile &amp;&amp; echo “exist” || echo “Not exist”<br>最终的结果可以告知我们是“exist”还是“Not exist”呢！那我知道 -e 是测试一个“文件”是否存在，如果还想要测试一下，还有很多选项可以供我们选择！</p>
</li>
<li><p>文件测试</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>测试的标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-e（同-a）</td>
<td>该“文件名”是否存在？</td>
</tr>
<tr>
<td>-f</td>
<td>该“文件名”是否存在且为文件（file）</td>
</tr>
<tr>
<td>-d</td>
<td>该“文件名”是否存在且为目录（directory）</td>
</tr>
<tr>
<td>-c</td>
<td>是否存在且为字符设备文件（character device）</td>
</tr>
<tr>
<td>-d</td>
<td>是否存在且为目录文件</td>
</tr>
<tr>
<td>-f</td>
<td>是否存在且为普通文件</td>
</tr>
<tr>
<td>-h（或-L）</td>
<td>存在且为符号链接文件</td>
</tr>
<tr>
<td>-p</td>
<td>是否存在且为套接字文件</td>
</tr>
<tr>
<td>-r</td>
<td>是否存在且可读</td>
</tr>
<tr>
<td>-w</td>
<td>是否存在且可写</td>
</tr>
<tr>
<td>-x</td>
<td>是否存在且可执行</td>
</tr>
<tr>
<td>-u</td>
<td>是否存在且拥有suid 权限</td>
</tr>
<tr>
<td>-g</td>
<td>是否存在且拥有sgid 权限</td>
</tr>
<tr>
<td>-k</td>
<td>是否存在且拥有sticky 权限</td>
</tr>
<tr>
<td>-s</td>
<td>是否存在且非空</td>
</tr>
<tr>
<td>-t fd</td>
<td>fd表示文件描述符是否已经打开且与某终端相关</td>
</tr>
<tr>
<td>-N</td>
<td>文件自动上一次被读取之后是否被修改过</td>
</tr>
<tr>
<td>-O</td>
<td>当前有效用户是否为文件属主</td>
</tr>
<tr>
<td>-G</td>
<td>当前有效用户是否为文件属组</td>
</tr>
</tbody></table>
<ul>
<li>字符串测试</li>
</ul>
<table>
<thead>
<tr>
<th>测试的标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>是否等于；</td>
</tr>
</tbody></table>
<blockquote>
<p>| ascii 码是否大于ascii码<br>&lt;|是否小于<br>!=|是否不等于<br>=~|左侧字符串是否能够被右侧的PATTERN所 所 匹配（）Ps:  此表达式一般用于[[ ]] 中；扩展的正则表达式）<br>-z  |字符串是否为空，空为真，不空为假<br>-n |字符串是否不空，不空为真，空为假</p>
</blockquote>
<ul>
<li>数值测试</li>
</ul>
<table>
<thead>
<tr>
<th>测试的标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-gt</td>
<td>是否大于</td>
</tr>
<tr>
<td>-ge</td>
<td>是否大于等于</td>
</tr>
<tr>
<td>-eq</td>
<td>是否等于</td>
</tr>
<tr>
<td>-ne</td>
<td>是否不等于</td>
</tr>
<tr>
<td>-lt</td>
<td>是否小于</td>
</tr>
<tr>
<td>-le</td>
<td>是否</td>
</tr>
</tbody></table>
<ul>
<li>双目测试</li>
</ul>
<table>
<thead>
<tr>
<th>测试的标志</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-ef</td>
<td>是否指向同一个设备上的相同inode</td>
</tr>
<tr>
<td>-nt</td>
<td>是否新于前一个文件</td>
</tr>
<tr>
<td>-ot</td>
<td>是否旧于前一个文件</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filetest1   -ef filetest2: filetest1 与filetest2 是否指向同一个设备上的相同inode</span><br><span class="line">filetest1 -nt filetest2: filetest1 是否新于 于filetest2</span><br><span class="line">filetest1 -ot filetest2: filetest1 是否旧于 于filetest2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Bash 的组合测试条件</p>
</li>
<li><p>第一种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND1 &amp;&amp; COMMAND2  并且</span><br><span class="line">COMMAND1 || COMMAND2  或者</span><br><span class="line">! COMMAND 非 非</span><br><span class="line">如：[[ -r FILE ]] &amp;&amp; [[ -w FILE ]]</span><br></pre></td></tr></table></figure></li>
<li><p> 第二种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPRESSION1 -a EXPRESSION2  并且</span><br><span class="line">EXPRESSION1 -o EXPRESSION2  或者</span><br><span class="line">! EXPRESSION</span><br></pre></td></tr></table></figure>
<p>必须使用测试命令进行</p>
</li>
<li><p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ -z “$HOSTNAME” -o $HOSTNAME &quot;&#x3D;&#x3D;&quot;localhost.localdomain&quot; ] &amp;&amp; hostname www.magedu.com</span><br><span class="line">[ -f &#x2F;bin&#x2F;cat -a -x &#x2F;bin&#x2F;cat ] &amp;&amp; cat &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础--shell脚本</title>
    <url>/post/79f74127.html</url>
    <content><![CDATA[<p>最近小白学习了shell脚本的基础编程，感觉有必要对最近所学知识进行一次简单的总结，所以写了这一篇博客，可能会有所不足。请大家指正，后期在学习过后，会进行完善的。<br>下面先说下shell登陆的两种方式</p>
<h1 id="交互式登录："><a href="#交互式登录：" class="headerlink" title="交互式登录："></a>交互式登录：</h1><ul>
<li> 直接通过终端输入账号密码登录</li>
<li> 使用“su - UserName”  切换的用户<br>执行顺序：<code>/etc/profile --&gt; /etc/profile.d/*.sh --&gt;~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc</code></li>
</ul>
<a id="more"></a>

<h1 id="非交互式登录："><a href="#非交互式登录：" class="headerlink" title="非交互式登录："></a>非交互式登录：</h1><ul>
<li>su UserName</li>
<li> 图形界面下打开的终端</li>
<li> 执行脚本</li>
<li> 任何其它的bash 实例<br>执行顺序： <code>~/.bashrc --&gt; /etc/bashrc --&gt;/etc/profile.d/*.sh</code></li>
</ul>
<p>关于bash配置文件生效范围</p>
<ul>
<li><p>全局配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;profile</span><br><span class="line">&#x2F;etc&#x2F;profile.d&#x2F;*.sh</span><br><span class="line">&#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>个人配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;.bash_profile</span><br><span class="line">~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<h1 id="创建Shell脚本"><a href="#创建Shell脚本" class="headerlink" title="创建Shell脚本"></a>创建Shell脚本</h1><p>利用vim等文本编辑工具创建文本文件 第一行必须包括shell 声明序列：#!<br>例如：</p>
<p>  #!/bin/bash<br>  #!/usr/bin/python<br>  #!/usr/bin/perl      </p>
</li>
<li><p>shell 脚本的用途：</p>
<pre><code>-   1、 自动化执行常用命令
-   2、执行系统管理和故障排除
-   3、 创建简单的应用程序
-   4、创建文本或者文件
</code></pre>
</li>
</ul>
<h1 id="运行脚本文件"><a href="#运行脚本文件" class="headerlink" title="运行脚本文件"></a>运行脚本文件</h1><p>  首先先给予文本文件权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x $name.sh</span><br></pre></td></tr></table></figure>
<p>  直接运行脚本文件./$PATH/$name.sh或者$shell ./$PATH/$name.sh，接下来就是小白简单写了一个简单的脚本文件格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">[ $# -gt 1 ] &amp;&amp; &#123; echo &quot; must be a arg &quot;;exit;&#125;</span><br><span class="line">[ $# &#x3D;&#x3D; 0 ] &amp;&amp; read -p &quot;please input script name: &quot; name ||   name&#x3D;$1  </span><br><span class="line">[ -e $name ] &amp;&amp; &#123; echo &quot;the file is exist , please return the script   and input another name&quot;; exit ; &#125;</span><br><span class="line">touch $name</span><br><span class="line">echo &quot;#!&#x2F;bin&#x2F;bash</span><br><span class="line"># author:wangnan</span><br><span class="line"># mailbox:*********@163.com</span><br><span class="line"># QQ:********</span><br><span class="line"># blog:http:&#x2F;&#x2F;vinnywang.com</span><br><span class="line"># description:this is for wang </span><br><span class="line"># echo &quot; Your working directory is: $(pwd) &quot;</span><br><span class="line"># date &#96;date&#96;&quot;&gt;&quot;$name&quot;</span><br><span class="line">chmod +x &quot;$name&quot;</span><br><span class="line">vim $name</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure>

<p>这个脚本的功能是创建脚本模板，首先是判断运行脚本时是否后加参数，不加的话就退出，加的话，判断是否名字相同，相同的话重新命名另外一个名字，之后自动添加执行权限，并打开该脚本，unset</p>
<h1 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h1><p>  检测脚本中的语法错误</p>
<pre><code>bash -n /$PATH/$name.sh
</code></pre>
<p>  调试执行</p>
<pre><code>bash -x /$PATH/$name.sh
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础--算数运算</title>
    <url>/post/7ad2fff2.html</url>
    <content><![CDATA[<h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><p>（1）bash 中的算术运算:</p>
<p><code>help let +, -, *, /, % 取模（取余）, ** （乘方）</code></p>
<p>（2）实现算术运算：</p>
<ul>
<li>(1) let var= 算术表达式</li>
<li>(2) var=$[ 算术表达式]</li>
<li>(3) var=$(( 算术表达式))</li>
<li>(4) var=$(expr arg1 arg2 arg3 …)</li>
<li>(5) declare –i var =  数值</li>
<li>(6) echo ‘ 算术表达式’ | bc</li>
<li>(7) 乘法符号有的场景需要转义<code>*</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# num1&#x3D;1</span><br><span class="line">[root@localhost ~]# num2&#x3D;2</span><br><span class="line">[root@localhost ~]# let sum&#x3D;$&#123;num1&#125;+$&#123;num2&#125; &amp;&amp; echo $sum</span><br><span class="line">3</span><br><span class="line">[root@localhost ~]# echo $[$&#123;num1&#125;+$&#123;num2&#125;]</span><br><span class="line">3</span><br><span class="line">[root@localhost ~]# echo $(($&#123;num1&#125;+$&#123;num2&#125;))</span><br><span class="line">3</span><br><span class="line">[root@localhost ~]# mult&#x3D;$(expr $&#123;num1&#125; \* $&#123;num2&#125;)</span><br><span class="line">[root@localhost ~]# echo $mult</span><br><span class="line">2</span><br><span class="line">[root@localhost ~]# declare -i var&#x3D;$&#123;num1&#125;+$&#123;num2&#125; &amp;&amp; echo $sum</span><br><span class="line">3</span><br><span class="line">[root@localhost ~]# echo &quot;$&#123;num1&#125;+$&#123;num2&#125;&quot; | bc</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（3）增强型赋值：<code>+=, -=, *=, /=, %=</code></p>
<pre><code>let var OPER value
</code></pre>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自增，自减：</span><br><span class="line">let var+&#x3D;1</span><br><span class="line">let var++</span><br><span class="line">let var--</span><br><span class="line">[root@localhost ~]# var&#x3D;0</span><br><span class="line">[root@localhost ~]# let var+&#x3D;1 &amp;&amp; echo $var</span><br><span class="line">1</span><br><span class="line">[root@localhost ~]# let var++ &amp;&amp; echo $var</span><br><span class="line">2</span><br><span class="line">[root@localhost ~]# let var-- &amp;&amp; echo $var</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础--语句流程控制</title>
    <url>/post/4b80141a.html</url>
    <content><![CDATA[<h1 id="语句流程控制"><a href="#语句流程控制" class="headerlink" title="语句流程控制"></a>语句流程控制</h1><h2 id="条件选择if（if语句可以进行嵌套）"><a href="#条件选择if（if语句可以进行嵌套）" class="headerlink" title="条件选择if（if语句可以进行嵌套）"></a>条件选择if（if语句可以进行嵌套）</h2><ul>
<li>单分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  判断条件;then</span><br><span class="line">        条件为真的分支代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li>双分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  判断条件; then</span><br><span class="line">        条件为真的分支代码</span><br><span class="line">else</span><br><span class="line">        条件为假的分支代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li>多分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  判断条件 1 ; then</span><br><span class="line">        条件为真的分支代码</span><br><span class="line">elif  判断条件 2 ; then</span><br><span class="line">        条件为真的分支代码</span><br><span class="line">elif  判断条件 3 ; then</span><br><span class="line">        条件为真的分支代码</span><br><span class="line">else</span><br><span class="line">        以上条件都为假的分支代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
Ps：这是一个测试例子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据命令的退出状态来执行命令</span><br><span class="line">if ping -c1 -W2 station1 &amp;&gt; &#x2F;dev&#x2F;null; then</span><br><span class="line">                echo &#39;Station1 is UP&#39;</span><br><span class="line">        elif grep &quot;station1&quot; ~&#x2F;maintenance.txt &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">                then</span><br><span class="line">                echo &#39;Station1 is undergoing maintenance‘</span><br><span class="line">        else</span><br><span class="line">                echo &#39;Station1 is unexpectedly DOWN!&#39;</span><br><span class="line">        exit 1</span><br><span class="line">      fi</span><br></pre></td></tr></table></figure>

<h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><p>条件判断和函数结合可以Linux系统脚本经常出现</p>
<pre><code>  case 变量引用 in
  PAT1)
          分支1
          ;;
  PAT2)
          分支2
          ;;
  ...
  *)
          默认分支
          ;;
  esac
</code></pre>
<p>PS:这个是具体的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #! &#x2F;bin&#x2F;bash</span><br><span class="line">case $1 in</span><br><span class="line">1) echo &quot;你输入了1&quot;;;</span><br><span class="line">2) echo &quot;你输入了2&quot;;;</span><br><span class="line">*) echo &quot;你输入了其他&quot;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS安装Homebrew</title>
    <url>/post/30584.html</url>
    <content><![CDATA[<h1 id="MacOS安装Homebrew-官方网站Homebrew"><a href="#MacOS安装Homebrew-官方网站Homebrew" class="headerlink" title="MacOS安装Homebrew 官方网站Homebrew"></a>MacOS安装Homebrew 官方网站<a href="https://brew.sh/">Homebrew</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span> </span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)</span>&quot;</span> </span><br></pre></td></tr></table></figure>
<p>Ps: ==很多情况会出现安装失败的问题，其实是因为下载的站点在国外，如果有代理会好点，但是也有可能下载站点拥塞导致下载失败，不要着急慢慢下载就行了。大概回报错，类似于这样==  <code>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</code> </p>
<h1 id="brew很慢的解决方案"><a href="#brew很慢的解决方案" class="headerlink" title="brew很慢的解决方案"></a>brew很慢的解决方案</h1><h2 id="创建HomeBrew文件夹"><a href="#创建HomeBrew文件夹" class="headerlink" title="创建HomeBrew文件夹"></a>创建HomeBrew文件夹</h2><p>首先确保<code>/usr/local/Homebrew</code>文件夹不存在，存在的话删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/Homebrew </span><br><span class="line">sudo mkdir /usr/<span class="built_in">local</span>/Homebrew </span><br></pre></td></tr></table></figure>
<h2 id="git克隆"><a href="#git克隆" class="headerlink" title="git克隆"></a>git克隆</h2><p>随便选择哪一个都可以不要重复执行，大概3-5分钟吧，网速很不好的话会很慢。尽量网速稳定的时候在操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> https://mirrors.aliyun.com/homebrew/brew.git /usr/<span class="built_in">local</span>/Homebrew </span><br></pre></td></tr></table></figure>
<h2 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h2><p><code>rm -rf </code>可以不用执行，只要你之前没有操作过的话。如果报错<code>mkdir: /usr/local/Homebrew: File exists</code> 就必须要执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sduo rm -rf /usr/<span class="built_in">local</span>/bin/brew </span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/Homebrew/bin/brew /usr/<span class="built_in">local</span>/bin/brew </span><br></pre></td></tr></table></figure>
<h2 id="创建core文件夹并再次git克隆"><a href="#创建core文件夹并再次git克隆" class="headerlink" title="创建core文件夹并再次git克隆"></a>创建core文件夹并再次git克隆</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core </span><br><span class="line">sudo mkdir -p /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core  </span><br><span class="line">sudo git <span class="built_in">clone</span> https://mirrors.aliyun.com/homebrew/homebrew-core.git /usr/<span class="built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core </span><br></pre></td></tr></table></figure>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>为当前用户授权能够访问的权限</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/<span class="built_in">local</span>/Homebrew</span><br><span class="line"><span class="comment"># 替换 homebrew-bottles: </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile </span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile </span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile </span><br></pre></td></tr></table></figure>
<h2 id="回退默认源"><a href="#回退默认源" class="headerlink" title="回退默认源"></a>回退默认源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 退回到默认的源</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> </span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git </span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span> </span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>


<h1 id="常用的brew命令"><a href="#常用的brew命令" class="headerlink" title="常用的brew命令"></a>常用的<code>brew</code>命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 </span></span><br><span class="line">brew update </span><br><span class="line"><span class="comment"># 自检 </span></span><br><span class="line">brew doctor </span><br><span class="line"><span class="comment"># 列出当前所有的brew的软件包 </span></span><br><span class="line">brew list </span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">brew install [包名]</span><br><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">brew install git</span><br><span class="line"><span class="comment"># 更新所有</span></span><br><span class="line">brew upgrade</span><br><span class="line"><span class="comment"># 更新指定包</span></span><br><span class="line">brew upgrade [包名]</span><br><span class="line"><span class="comment"># 清理所有包的旧版本</span></span><br><span class="line">brew cleanup </span><br><span class="line"><span class="comment"># 清理指定包的旧版本</span></span><br><span class="line">brew cleanup [包名]</span><br><span class="line"><span class="comment"># 查看可清理的旧版本包，不执行实际操作</span></span><br><span class="line">brew cleanup -n </span><br><span class="line"><span class="comment"># 查询可更新的包</span></span><br><span class="line">brew outdated</span><br><span class="line"><span class="comment"># 锁定某个包</span></span><br><span class="line">brew pin <span class="variable">$FORMULA</span>  </span><br><span class="line"><span class="comment"># 取消锁定</span></span><br><span class="line">brew unpin <span class="variable">$FORMULA</span></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">brew uninstall [包名]</span><br><span class="line"><span class="comment"># 卸载git</span></span><br><span class="line">brew uninstall git</span><br><span class="line"><span class="comment"># 查询可用包</span></span><br><span class="line">brew search [包名]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS中iterm2支持上传下载</title>
    <url>/post/5a936e5c.html</url>
    <content><![CDATA[<h1 id="Mac-中-iterm2-支持上传下载"><a href="#Mac-中-iterm2-支持上传下载" class="headerlink" title="Mac 中 iterm2 支持上传下载"></a>Mac 中 iterm2 支持上传下载</h1><h2 id="安装-lrzsz"><a href="#安装-lrzsz" class="headerlink" title="安装 lrzsz"></a>安装 lrzsz</h2><p>首先安装<code>lrzsz</code>，如果没有 brew 可以直接一键安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 没有 brew 执行这个命令</span><br><span class="line">&#x2F;bin&#x2F;zsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;cunkai&#x2F;HomebrewCN&#x2F;raw&#x2F;master&#x2F;Homebrew.sh)&quot;</span><br><span class="line"># 安装 lrzsz</span><br><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装上传下载依赖脚本"><a href="#安装上传下载依赖脚本" class="headerlink" title="安装上传下载依赖脚本"></a>安装上传下载依赖脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -pv &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">cat &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-recv-zmodem.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Author: Matt Mastracci (matthew@mastracci.com)</span><br><span class="line"># AppleScript from http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;4309087&#x2F;cancel-button-on-osascript-in-a-bash-script</span><br><span class="line"># licensed under cc-wiki with attribution required</span><br><span class="line"># Remainder of script public domain</span><br><span class="line"></span><br><span class="line">#COMMAND&#x3D;$(which rz)</span><br><span class="line"></span><br><span class="line">if [[ -f &#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;rz ]]; then</span><br><span class="line">	COMMAND&#x3D;&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;rz</span><br><span class="line">else</span><br><span class="line">	COMMAND&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;rz</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">osascript -e &#39;tell application &quot;iTerm2&quot; to version&#39; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;&amp; NAME&#x3D;iTerm2 || NAME&#x3D;iTerm</span><br><span class="line">if [[ $NAME &#x3D; &quot;iTerm&quot; ]]; then</span><br><span class="line">    FILE&#x3D;$(osascript -e &#39;tell application &quot;iTerm&quot; to activate&#39; -e &#39;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#39; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;)</span><br><span class="line">else</span><br><span class="line">    FILE&#x3D;$(osascript -e &#39;tell application &quot;iTerm2&quot; to activate&#39; -e &#39;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#39; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;)</span><br><span class="line">fi</span><br><span class="line">if [[ $FILE &#x3D; &quot;&quot; ]]; then</span><br><span class="line">    echo Cancelled.</span><br><span class="line">    # Send ZModem cancel</span><br><span class="line">    echo -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    sleep 1</span><br><span class="line">    echo</span><br><span class="line">    echo \# Cancelled transfer</span><br><span class="line">else</span><br><span class="line">    cd &quot;$FILE&quot;</span><br><span class="line">    $COMMAND --rename --escape --binary --bufsize 4096</span><br><span class="line">    sleep 1</span><br><span class="line">    echo</span><br><span class="line">    echo</span><br><span class="line">    echo \# Sent \-\&gt; $FILE</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-send-zmodem.sh</span><br><span class="line">###</span><br><span class="line"># @Author: your name</span><br><span class="line"> # @Date: 2019-12-11 01:03:06</span><br><span class="line"> # @LastEditTime: 2019-12-11 01:03:21</span><br><span class="line"> # @LastEditors: your name</span><br><span class="line"> # @Description: In User Settings Edit</span><br><span class="line"> # @FilePath: &#x2F;rzsz&#x2F;iterm2-send-zmodem.sh</span><br><span class="line"> ###</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Author: Matt Mastracci (matthew@mastracci.com)</span><br><span class="line"># AppleScript from http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;4309087&#x2F;cancel-button-on-osascript-in-a-bash-script</span><br><span class="line"># licensed under cc-wiki with attribution required</span><br><span class="line"># Remainder of script public domain</span><br><span class="line"></span><br><span class="line">#COMMAND&#x3D;$(which sz)</span><br><span class="line"></span><br><span class="line">if [[ -f &#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;sz ]]; then</span><br><span class="line">	COMMAND&#x3D;&#x2F;opt&#x2F;homebrew&#x2F;bin&#x2F;sz</span><br><span class="line">else</span><br><span class="line">	COMMAND&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;sz</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">osascript -e &#39;tell application &quot;iTerm2&quot; to version&#39; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;&amp; NAME&#x3D;iTerm2 || NAME&#x3D;iTerm</span><br><span class="line">if [[ $NAME &#x3D; &quot;iTerm&quot; ]]; then</span><br><span class="line">    FILE&#x3D;$(osascript -e &#39;tell application &quot;iTerm&quot; to activate&#39; -e &#39;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#39; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;)</span><br><span class="line">else</span><br><span class="line">    FILE&#x3D;$(osascript -e &#39;tell application &quot;iTerm2&quot; to activate&#39; -e &#39;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#39; -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;)</span><br><span class="line">fi</span><br><span class="line">if [[ $FILE &#x3D; &quot;&quot; ]]; then</span><br><span class="line">    echo Cancelled.</span><br><span class="line">    # Send ZModem cancel</span><br><span class="line">    echo -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    sleep 1</span><br><span class="line">    echo</span><br><span class="line">    echo \# Cancelled transfer</span><br><span class="line">else</span><br><span class="line">    $COMMAND &quot;$FILE&quot; --escape --binary --bufsize 4096</span><br><span class="line">    sleep 1</span><br><span class="line">    echo</span><br><span class="line">    echo \# Received &quot;$FILE&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 授权</span><br><span class="line">chmod 777 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-*</span><br></pre></td></tr></table></figure>
<h2 id="设置-iterm2"><a href="#设置-iterm2" class="headerlink" title="设置 iterm2"></a>设置 iterm2</h2><p>打开 <code>iterm2</code> 左上角Preferences -&gt; Profiles -&gt; Default -&gt; Advanced -&gt; Triggers，点击 Edit按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\*\*B0100</span><br><span class="line">Run Silent Coprocess</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-send-zmodem.sh</span><br><span class="line">\*\*B00000000000000</span><br><span class="line">Run Silent Coprocess</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure>

<p>配置完成， 就可以愉快的玩耍了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python--文件读写操作</title>
    <url>/post/c12f04da.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python–文件读写操作"><a href="#Python–文件读写操作" class="headerlink" title="Python–文件读写操作"></a>Python–文件读写操作</h1><blockquote>
<p>程序执行都是在内存中进行操作的,如果需要落盘就需要单独的执行文件写操作<br>==直接使用下面的模式打开文件的时候需要单独进行文件的关闭操作,默认这个操作是不会自动关闭文件的,需要最后单独执行下,下面会单独介绍下不用直接关闭的操作方式==</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 最简单的创建一个a.txt的文件,然后进行写模式,括号里面最后的&#96;w&#96;代表的是写,默认是读(r)模式</span><br><span class="line">file1 &#x3D; open(&quot;a.txt&quot;, &quot;w&quot;)</span><br><span class="line">file1.write(&quot;hello&quot;)</span><br><span class="line">file1.close()</span><br><span class="line"># 必须要进行文件的关闭操作,否则会导致文件一直占用大量的内存空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打开a.txt文件进行读操作 </span><br><span class="line">file1 &#x3D; open(&quot;a.txt&quot;, &quot;r&quot;)</span><br><span class="line">test &#x3D; file1.read()</span><br><span class="line">print(test)</span><br><span class="line">file1.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二种方式:不用直接关闭文件的操作<br>==后面括号里面有个(a)这个是一种追加模式,当文件有的时候就会把新内容直接追加到文件的末尾行==</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;a.txt&quot;, &quot;a&quot;) as file1:</span><br><span class="line">    file1.write(&quot; world&quot;)</span><br><span class="line">	file1 &#x3D; open(&quot;a.txt&quot;, &quot;r&quot;)</span><br><span class="line">	test &#x3D; file1.read()</span><br><span class="line">	print(test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&quot;a.txt&quot;, &quot;w+&quot;, encoding&#x3D;&quot;utf-8&quot;) as file1:</span><br><span class="line">    file1.write(&quot;你好&quot;)</span><br><span class="line">    test &#x3D; file1.read()</span><br><span class="line">    print(test)</span><br></pre></td></tr></table></figure>
<h1 id="文件访问模式的汇总"><a href="#文件访问模式的汇总" class="headerlink" title="文件访问模式的汇总"></a>文件访问模式的汇总</h1><table>
<thead>
<tr>
<th align="left">访问模式</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">只⽤于读取, 默认模式。⽂件不存在,会报错</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">只⽤于写⼊。⽂件存在则先清空内容, ⽂件不存在，创建新⽂件</td>
</tr>
<tr>
<td align="left">a</td>
<td align="right">只⽤于写⼊。⽂件存在则追加内容, ⽂件不存在，创建新⽂件</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="right">⽤于读写。⽂件不存在,会报错</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="right">⽤于读写。⽂件存在则先清空内容, ⽂件不存在，创建新⽂件</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="right">⽤于读写。⽂件存在则追加内容, ⽂件不存在，创建新⽂件</td>
</tr>
<tr>
<td align="left">==具体的使用方法,大家可以在网上单独在搜索下,这里就不一一介绍了==</td>
<td align="right"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数--装饰器</title>
    <url>/post/ce96d800.html</url>
    <content><![CDATA[<h1 id="Python函数–装饰器"><a href="#Python函数–装饰器" class="headerlink" title="Python函数–装饰器"></a>Python函数–装饰器</h1><h2 id="装饰器的定义"><a href="#装饰器的定义" class="headerlink" title="装饰器的定义"></a>装饰器的定义</h2><p>给已有函数增加额外的功能的函数, 本质上和闭包类似<br>遵循<code>封闭开放</code>的代码原则</p>
<ul>
<li>封闭:尽量少的修改原来的代码</li>
<li>开放:可以添加额外的功能<a id="more"></a>
<h2 id="装饰器的语法糖用法"><a href="#装饰器的语法糖用法" class="headerlink" title="装饰器的语法糖用法"></a>装饰器的语法糖用法</h2></li>
</ul>
<blockquote>
<p>语法糖的理解:<br>形象的理解为,加了一层糖衣包装,.但是本质不便还是一颗糖<br>函数还是函数,但是在函数外部进行了处理,从而达到装饰的作用</p>
</blockquote>
<h2 id="装饰器的使用"><a href="#装饰器的使用" class="headerlink" title="装饰器的使用"></a>装饰器的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一步闭包</span><br><span class="line"># 第二步@语法糖</span><br><span class="line">def set_fun(func):  # 这个就是传入要被装饰的函数名或者叫引用</span><br><span class="line">	def call_fun():</span><br><span class="line">		print(&quot;函数自身内存地址:&quot;,func)</span><br><span class="line">		# 调用原先的函数</span><br><span class="line">		func()</span><br><span class="line">	return call_fun</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set_fun  # @set_fun &#x3D;&#x3D;&#x3D;&gt; test &#x3D; set_fun(test),这个就是语法糖的使用,前面是@后面跟上闭包的外层函数的名字即可,不加括号</span><br><span class="line">def test():</span><br><span class="line">	print(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>上面出来了神奇的一幕,竟然先执行了函数<code>set_fun</code>最后在执行了函数自身的代码.这个就是装饰器的作用,<code>test</code>是原本的业务代码,我们遵循<code>封闭开放</code>的原则,在不改动原先代码的时候,同时也添加了新的功能.</p>
<p>这个函数执行的顺序是可变的,有需求是需要先打印<code>test函数</code>输出,最后在调用语法糖的内容,只需要吧<code>func()</code>放在<code>print</code>前面即可,不管是否是在前在后都是可以的.</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础 --输入输出</title>
    <url>/post/ea5dd043.html</url>
    <content><![CDATA[<h1 id="Python基础-–输入输出"><a href="#Python基础-–输入输出" class="headerlink" title="Python基础 –输入输出"></a>Python基础 –输入输出</h1><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><ul>
<li>如果需要同时输出数字和字符的时候,需要格式化操作符</li>
<li>格式化操作符:专门处理字符串中的格式<pre><code>  - 包含 `%`的字符串被称为格式化字符串
  - `%`和不同的字符进行连用,不同的数据需要不通的格式化字符
</code></pre>
<table>
<thead>
<tr>
<th align="left">常用格式化字符</th>
<th align="right">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%s</td>
<td align="right">字符串</td>
</tr>
<tr>
<td align="left">%d</td>
<td align="right">有符号十进制的整数,%06d 输出的整数显示位数,不足的地方使用0补全</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="right">浮点数<code>%.2f</code>表示显示小数点的后两位</td>
</tr>
<tr>
<td align="left">%%</td>
<td align="right">输出%</td>
</tr>
</tbody></table>
<a id="more"></a>
<h2 id="变量输出实例"><a href="#变量输出实例" class="headerlink" title="变量输出实例"></a>变量输出实例</h2><blockquote>
<p>需求:定义整数变量 student_no，输出 我的学号是 000001</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student_no &#x3D; 1</span><br><span class="line">print ( &quot;学号是%06d&quot; % student_no)</span><br><span class="line"># %06d对整数进行站位,当不足6位的时候会进行补操作</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需求:定义小数 price、weight、total_price，输出苹果单价 9.00 元／斤，购买了5.00 斤，需要支付 45.00 元</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">price &#x3D; 6.5</span><br><span class="line">weight &#x3D; 3.5</span><br><span class="line">total_price &#x3D; price * weight</span><br><span class="line">print( &quot; 总价为 : %.2f &quot; %  total_price  )</span><br><span class="line"># %f是对于浮点小数进行站位,%.2f是对小数点保留后两位</span><br><span class="line"></span><br><span class="line"># 如果需要对多个数据进行站位,需要把真实数据括号包裹,并以逗号分隔</span><br><span class="line">&quot;&quot;&quot;定义小数 price、weight、total_price，输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元&quot;&quot;&quot;</span><br><span class="line">print( &quot;苹果单价: %.2f 元&#x2F;斤,重量:%.2f 斤,总价:%.2f元&quot; % (price,weight,total_price))</span><br><span class="line"></span><br><span class="line"># %s 可以对任意类型进行站位,包含字符串.%5s表示站位5个字符空间</span><br><span class="line">print( &quot;苹果单价: %5s元&#x2F;斤,重量: %s斤,总价: %5s元&quot; % (price,weight,total_price))</span><br></pre></td></tr></table></figure>
<h2 id="变量输入实例"><a href="#变量输入实例" class="headerlink" title="变量输入实例"></a>变量输入实例</h2><blockquote>
<p>目前暂时只有两个函数<code>print</code> 和<code>type</code></p>
</blockquote>
<ul>
<li>   input 用户输入的 任何内容Python都认为是一个<code>字符串(str)</code></li>
<li>   type 查看对应的变量<code>type(x)</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量(被当做字符串)  &#x3D; input(对应信息)</span><br></pre></td></tr></table></figure>
<h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2></li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int(x)</td>
<td align="right">将x转化为整型</td>
</tr>
<tr>
<td align="left">float(x)</td>
<td align="right">将x转化为浮点型</td>
</tr>
<tr>
<td align="left"><code>浮点型的字符串无法转换为int,比如int(1.5)会出现报错</code></td>
<td align="right"></td>
</tr>
</tbody></table>
<blockquote>
<p>变量类型的实例<br>需求:计算随机金额的总价并保留精度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># content &#x3D; input( &quot;请输入内容:&quot;)</span><br><span class="line"># print( &quot;输入的内容为:%s&quot; % content)</span><br><span class="line"># print( type( content ))</span><br><span class="line"># #  返回是一个字符串的类型</span><br><span class="line"></span><br><span class="line">price_str &#x3D; input( &quot;单价:&quot;)</span><br><span class="line">weight_str &#x3D; input( &quot;重量:&quot;)</span><br><span class="line"></span><br><span class="line">#以上内容全部都是字符串类型不能直接计算,需要单独转化类型</span><br><span class="line"></span><br><span class="line">price &#x3D; float( price_str)</span><br><span class="line">weight &#x3D; float( weight_str)</span><br><span class="line">total_price &#x3D; price * weight</span><br><span class="line"></span><br><span class="line">print( &quot;总价:%5s&quot; % total_price  )</span><br><span class="line"></span><br><span class="line"># round (数据  ,  保留位数)   保留指定的位数,进行四舍五入,解决浮点运算精度缺失问题</span><br><span class="line">total_price &#x3D; round( price * weight , 4)</span><br><span class="line">print( total_price)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--Python安装</title>
    <url>/post/8f87159e.html</url>
    <content><![CDATA[<h1 id="Python基础–Python安装"><a href="#Python基础–Python安装" class="headerlink" title="Python基础–Python安装"></a>Python基础–Python安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">rm -rf &#x2F;etc&#x2F;yum.repos.d&#x2F;*</span><br><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">yum -y install wget</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br><span class="line"></span><br><span class="line">yum install epel-release -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下载Python</span><br><span class="line">url: https:&#x2F;&#x2F;www.python.org&#x2F;downloads&#x2F;source&#x2F;</span><br><span class="line">选择所需的版本下载, 我这里选择的是Linux系统的Python3.8.6</span><br><span class="line"></span><br><span class="line">cd &#x2F;home</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.8.6&#x2F;Python-3.8.6.tar.xz</span><br><span class="line"></span><br><span class="line"># 安装系统依赖包</span><br><span class="line">yum install -y python-devel zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line">yum update -y</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -xvf Python-3.8.6.tar.xz</span><br><span class="line"></span><br><span class="line"># 编译安装  指定路径 并添加ssl模块</span><br><span class="line">cd Python-3.8.6</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 --with-ssl</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"># 添加软连接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--break 和 countin</title>
    <url>/post/275c8a84.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–break-和-countin"><a href="#Python基础–break-和-countin" class="headerlink" title="Python基础–break 和 countin"></a>Python基础–break 和 countin</h1><!-- more -->
<blockquote>
<p>break和continue只能在循环内部进行添加</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 1</span><br><span class="line">while i &lt;&#x3D; 5:</span><br><span class="line">    print(i)</span><br><span class="line">    if i &#x3D;&#x3D; 3:</span><br><span class="line">        break  # 一旦执行到break, 就会立即跳出循环, 向后执行</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">print(&quot;完成&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i &#x3D; 1</span><br><span class="line">while i &lt;&#x3D; 5:</span><br><span class="line">    if i &#x3D;&#x3D; 3:</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">        continue  # 一旦执行到continue, 不会再执行本次循环中后续的代码, 而是立即进行下一次循环判断</span><br><span class="line">    print(i)  # 1  2  4  5</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">print(&quot;完成&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--if条件判断语句</title>
    <url>/post/e9c34ef8.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–if条件判断语句"><a href="#Python基础–if条件判断语句" class="headerlink" title="Python基础–if条件判断语句"></a>Python基础–if条件判断语句</h1><blockquote>
<p>如下为对应格式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 要判断的条件:</span><br><span class="line">    条件成立时，要做的事情</span><br><span class="line">    ……</span><br><span class="line">else:</span><br><span class="line">    条件不成立时，要做的事情</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需求:判断输入年龄是否大于18岁,大于18输出成年,否则输出未成年</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age &#x3D; int( input ( &quot;请输入你的年龄:&quot; ) )</span><br><span class="line">if age &gt;&#x3D; 18:</span><br><span class="line">    # if语句代表判断成功之后执行的结果</span><br><span class="line">    print( &quot;成年&quot;)</span><br><span class="line">else:</span><br><span class="line">    # else 上面的条件不满足会全部执行这个结果</span><br><span class="line">    print( &quot;未成年&quot;)</span><br><span class="line">print(  &quot;没有缩进,会直接输出&quot; )</span><br><span class="line"># 无论是否成立均会执行,因为不属于循环里面</span><br></pre></td></tr></table></figure>
<p><code>PS:特别注意:数字直接作为判断条件的时候,非0数为True,0位False</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; input( &quot;请输入数字,没有请直接回车&quot;)</span><br><span class="line">if  num:</span><br><span class="line">    print(&quot;True&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;False&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="elif条件语句"><a href="#elif条件语句" class="headerlink" title="elif条件语句"></a>elif条件语句</h2><blockquote>
<p>如下为对应格式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1:</span><br><span class="line">    条件1满足执行的代码</span><br><span class="line">    ……</span><br><span class="line">elif 条件2:</span><br><span class="line">    条件2满足时，执行的代码</span><br><span class="line">    ……</span><br><span class="line">elif 条件3:</span><br><span class="line">    条件3满足时，执行的代码</span><br><span class="line">    ……</span><br><span class="line">else:</span><br><span class="line">    以上条件都不满足时，执行的代码</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需求: 定义holiday,情人节买玫瑰,平安夜,买苹果.生日,买蛋糕</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">holiday &#x3D; input( &quot;请输入和女友在一起过得节日(情人节,生日,平安夜):&quot;)</span><br><span class="line">if holiday &#x3D;&#x3D; &quot;情人节&quot;:</span><br><span class="line">    print(&quot;买玫瑰看电影&quot;)</span><br><span class="line">elif holiday &#x3D;&#x3D; &quot;生日&quot;:</span><br><span class="line">    print( &quot;买蛋糕&quot;)</span><br><span class="line">elif holiday &#x3D;&#x3D; &quot;平安夜&quot;:</span><br><span class="line">    print( &quot;吃苹果,吃大餐&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;每天都是节日&quot; )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需求: 判断乘客是否有票,有票可以进站,是否有刀子,刀子超过20CM输出不能进站</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">has_ticket &#x3D; input(&quot;有车票请输入True,没有输入False:&quot;)</span><br><span class="line">k_length &#x3D; input(&quot;是否有刀,有请输入刀的长度:&quot;)</span><br><span class="line">if has_ticket :</span><br><span class="line">    print(&quot;能进站&quot;)</span><br><span class="line">    if int(k_length) &gt;&#x3D; 20:</span><br><span class="line">        print(&quot;不能入内&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;可以入内&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无票不能进站&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>简单应用:猜拳</p>
</blockquote>
<ul>
<li>从控制台输入对应的石头（1）／剪刀（2）／布（3）</li>
<li>电脑随机出拳</li>
<li>判断对应的关系,并输出结果</li>
<li>判断关系<ul>
<li> 石头&gt;剪刀</li>
<li>   剪刀&gt;布</li>
<li> 布&gt;石头<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"># 导入随机模块,实现本项目的随机功能</span><br><span class="line">player &#x3D; int( input(&quot;请输入 石头（1）／剪刀（2）／布（3）:&quot;))</span><br><span class="line">computer &#x3D; random.randint (1,3)</span><br><span class="line"># randint(m,n)在mn的范围内随机取值.Ps:randint(2,5)随机取值(2,3,4,5)中的任意一个</span><br><span class="line">if ((player &#x3D;&#x3D; 1 and computer &#x3D;&#x3D; 2) or (player &#x3D;&#x3D; 2 and computer &#x3D;&#x3D; 3) or (player &#x3D;&#x3D; 3 and computer &#x3D;&#x3D;1 )):</span><br><span class="line">    print(&quot;玩家胜利&quot;)</span><br><span class="line">elif player &#x3D;&#x3D; computer:</span><br><span class="line">    print(&quot;平手&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;电脑胜利&quot;)</span><br></pre></td></tr></table></figure>
<code>Tips:</code>随机数扩展<br>导入随机数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br></pre></td></tr></table></figure>
<code>random.randint(a,b)</code> 返回a和b之间的数字,包含ab<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">random.randint(1, 3)  # 生成的随机数n: 1 &lt;&#x3D; n &lt;&#x3D; 3 </span><br><span class="line">random.randint(1, 1)  # 结果永远是 1   </span><br><span class="line">random.randint(2, 1)  # 该语句是错误的，下限必须小于上限</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础-- init和继承</title>
    <url>/post/46d7f174.html</url>
    <content><![CDATA[<h1 id="Python基础–-init和继承"><a href="#Python基础–-init和继承" class="headerlink" title="Python基础– init和继承"></a>Python基础– init和继承</h1><p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<blockquote>
<p>举例参考: 定义父类<code>Cat</code>和子类<code>SmaCat</code>这两个类均有<code>init方法</code>,最代码的使用对象调用子类的没有的init属性,但是父类却包含的方法.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.type &#x3D; &quot;猫&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SmaCat(Cat):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.color &#x3D; &quot;yellow&quot;</span><br><span class="line">        # 以下是继承父类的调用方法,没有父类的调用,最下面直接需要父类的init魔法方法,会出现报错</span><br><span class="line">        # Cat.__init__(self)</span><br><span class="line">        # super(SmaCat,self).__init__()</span><br><span class="line">        # super().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaohua &#x3D; SmaCat()</span><br><span class="line">print(xiaohua.type)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进一步改进,从而能够调用父类<code>Cat</code>的<code>init</code>方法,从而达到能够子类能够调用父类的<code>init方法</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def __init__(self, type):</span><br><span class="line">        self.type &#x3D; type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SmaCat(Cat):</span><br><span class="line">    def __init__(self, type):</span><br><span class="line">        Cat.__init__(self, type)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaohua &#x3D; SmaCat(&quot; huahua &quot;)</span><br><span class="line">print(xiaohua.type)</span><br><span class="line">print(xiaohua)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--range与列表推导式</title>
    <url>/post/5c2354ce.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–range与列表推导式"><a href="#Python基础–range与列表推导式" class="headerlink" title="Python基础–range与列表推导式"></a>Python基础–range与列表推导式</h1><blockquote>
<p>range() 返回可迭代对象 可以是用for进行遍历<br>range() 函数主要配合是用for循环进行遍历计数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(m):# range的计数范围是[0,m)</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line"># range(m,n)  代表的是从[5,10)从5开始但是小于10    </span><br><span class="line">for i in range(5, 10):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>==range(m,n,a) mn代表的是范围,a代表的是步长<br>可以看做从m开始,1次循环是m加上1个a,2次加2个a,知道两者只和大于n是不在输出,跳出循环==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(5, 100, 20):</span><br><span class="line">    print(i)</span><br><span class="line">    i +&#x3D; 1</span><br></pre></td></tr></table></figure>
<h1 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h1><blockquote>
<p>默认i=0,从0开始进行计数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [i+1 for i in range(100)]</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>步长是2,不用使用i+2 即从2开始100以内的偶数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [i for i in range(2, 10, 2)]</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list1 &#x3D; [i+2 for i in range(2, 10, 2)]</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list1 &#x3D; [i for i in range(0, 10, 2) if (i % 3 &#x3D;&#x3D; 0 and i % 4 &#x3D;&#x3D; 0)]</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用匿名参数进行运算   lambda 参数1,参数2: 返回值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print((lambda num1, num2: num1 * num2)(3, 2))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--set操作</title>
    <url>/post/b4ad2595.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–set操作"><a href="#Python基础–set操作" class="headerlink" title="Python基础–set操作"></a>Python基础–set操作</h1><blockquote>
<p>无序集合<br>取出重复内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set1 &#x3D; &#123;3,4,5,1,3,2,6&#125;</span><br><span class="line">print(set1)</span><br><span class="line">print(type(set1))</span><br><span class="line"></span><br><span class="line"># 去重</span><br><span class="line">list1 &#x3D; [3, 4, 5, 1, 3, 2, 6]</span><br><span class="line">set2 &#x3D; set(list1)</span><br><span class="line">list1 &#x3D; list(set2)</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>公共语法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打印列表的最大值和最小值</span><br><span class="line">print(max(list1))</span><br><span class="line">print(min(list1))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--web服务端简单搭建</title>
    <url>/post/b770c3a1.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–web服务端简单搭建"><a href="#Python基础–web服务端简单搭建" class="headerlink" title="Python基础–web服务端简单搭建"></a>Python基础–web服务端简单搭建</h1><blockquote>
<p>实现步骤<br>1.获取用户请求路径<br>2.根据路径,返回指定内容<br>3.组装报文,返回给客户端<br>4.如果没有指定路径页面,返回404给到客户</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def client_exec(client):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 处理客户请求</span><br><span class="line">    :param client:客户端</span><br><span class="line">    :return: none</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data &#x3D; client.recv(1024)</span><br><span class="line">    if data:</span><br><span class="line">        # 解码为utf-8</span><br><span class="line">        decode_data &#x3D; data.decode(&quot;utf-8&quot;)</span><br><span class="line">        # 切割数据,最大切割次数是2</span><br><span class="line">        split_data &#x3D; decode_data.split(&quot; &quot;, maxsplit&#x3D;2)</span><br><span class="line">        if len(split_data) &gt; 2:</span><br><span class="line">            file_path &#x3D; split_data[1]</span><br><span class="line">            if file_path &#x3D;&#x3D; &quot;&#x2F;&quot;:</span><br><span class="line">                file_path &#x3D; &quot;&#x2F;index.html&quot;</span><br><span class="line">        else:</span><br><span class="line">            client.close()</span><br><span class="line">            return</span><br><span class="line">    else:</span><br><span class="line">        client.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">        # 判断path地址,并根据匹配访问指定页面</span><br><span class="line">    if file_path &#x3D;&#x3D; &quot;&#x2F;index.html&quot;:</span><br><span class="line"></span><br><span class="line">		# 组装http状态码为 200的响应头</span><br><span class="line">        rep_line &#x3D; &quot;http&#x2F;1.1 200 ok \r\n&quot;</span><br><span class="line">		# 因为这个地方是汉字,所以需要单独指定下文本格式类型,下同</span><br><span class="line">        rep_head &#x3D; &#39;content-type:text&#x2F;html;charset&#x3D;utf-8\r\n&#39;</span><br><span class="line">        rep_emp &#x3D; &quot;\r\n&quot;</span><br><span class="line">        rep_body &#x3D; &quot;你好&quot;</span><br><span class="line">        rep_cont &#x3D; rep_line + rep_head + rep_emp + rep_body</span><br><span class="line">        # 将发送出去的文本内容编码为&#96;utf-8&#96;在经过套接字发送给客户端</span><br><span class="line">        client.send(rep_cont.encode(&quot;utf-8&quot;))</span><br><span class="line">    else:</span><br><span class="line">		</span><br><span class="line">		# 组装http状态码为 404的响应头</span><br><span class="line">        rep_line &#x3D; &quot;http&#x2F;1.1 404 not found\r\n&quot;</span><br><span class="line">        rep_head &#x3D; &#39;content-type:text&#x2F;html;charset&#x3D;utf-8\r\n&#39;</span><br><span class="line">        rep_emp &#x3D; &quot;\r\n&quot;</span><br><span class="line">        rep_body &#x3D; &quot;页面有问题&quot;</span><br><span class="line">        rep_cont &#x3D; rep_line + rep_head + rep_emp + rep_body</span><br><span class="line">        client.send(rep_cont.encode(&quot;utf-8&quot;))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	主函数</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">    # 初始化套接字</span><br><span class="line">    server_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    # 设置端口复用</span><br><span class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</span><br><span class="line">    # 绑定端口</span><br><span class="line">    server_socket.bind((&#39;&#39;, 8081))</span><br><span class="line">    # 监听端口</span><br><span class="line">    server_socket.listen(128)</span><br><span class="line">    while True:</span><br><span class="line">        client, address &#x3D; server_socket.accept()</span><br><span class="line">        # 处理客户端信息</span><br><span class="line">        client_exec(client)</span><br><span class="line">        # 关闭端口</span><br><span class="line"></span><br><span class="line">    server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何访问,可以在pycharm中运行此程序,代码格式必须调好,python对应代码的缩进要求比较严格<br>当运行完这个代码之后,可以在本地的浏览器上直接输入<code>127.0.0.1:8081</code>进行访问即可,<br>Tips:表点符号全英文<br>分别测试<code>/</code>和非<code>/</code></p>
</blockquote>
<ul>
<li>上述代码,比较重要的点有2个地方,<ul>
<li>1.怎么获取到客户的访问路径,这里采用最简单的方式,<code>切片</code>,取到路径</li>
<li>2.根据上面取到的路径,进行判断.返回指定路径的界面.如果无界面,则返回<code>404</code></li>
</ul>
</li>
</ul>
<p>==目前这个是是最简单版的server的建设,后面,还会设置成多任务版的,当然还有最重要的动静分离.因为最近一直有点忙,所以更新上有点慢,请谅解==</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--while循环</title>
    <url>/post/3b117ed9.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–while循环"><a href="#Python基础–while循环" class="headerlink" title="Python基础–while循环"></a>Python基础–while循环</h1><blockquote>
<p>语法格式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while 条件(判断 变量是否满足条件):</span><br><span class="line">    条件满足时，做的事情1</span><br><span class="line">    条件满足时，做的事情2</span><br><span class="line">    条件满足时，做的事情3</span><br><span class="line">    ...(省略)...</span><br><span class="line"></span><br><span class="line">    修改变量</span><br></pre></td></tr></table></figure>
<ul>
<li>   1.定义变量,记录循环条件</li>
<li>2.执行循环判断</li>
<li>3.在循环体中,增加变量值,触发判断条件,终止循环<blockquote>
<p>需求:使用while重复打印”南风”4次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;0</span><br><span class="line">while i &lt;&#x3D; 3:</span><br><span class="line">    print (&quot;南风&quot;)</span><br><span class="line">    i+&#x3D;1</span><br></pre></td></tr></table></figure>
<h2 id="while循环累加"><a href="#while循环累加" class="headerlink" title="while循环累加"></a>while循环累加</h2><blockquote>
<p>直接求和到100</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum_num &#x3D; 0</span><br><span class="line">i &#x3D; 1</span><br><span class="line">while i&lt;&#x3D; 100:</span><br><span class="line">    sum_num &#x3D; sum_num +i</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">print( sum_num)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用整除的方式进行if循环判断,取整数的形式.100以内所有偶数求和.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum_num &#x3D; 0</span><br><span class="line">i &#x3D; 1</span><br><span class="line">while i&lt;&#x3D; 100:</span><br><span class="line">    if i % 2 &#x3D;&#x3D; 0:</span><br><span class="line">        sum_num &#x3D; sum_num +i</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">print( sum_num)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>加上一点点判断对于100以内的奇数进行求和.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum_num &#x3D; 0</span><br><span class="line">i &#x3D; 1</span><br><span class="line">while i&lt;&#x3D; 100:</span><br><span class="line">    if i % 2 !&#x3D; 0:</span><br><span class="line">        sum_num &#x3D; sum_num +i</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line">print( sum_num)</span><br></pre></td></tr></table></figure>
<h2 id="while循环嵌套"><a href="#while循环嵌套" class="headerlink" title="while循环嵌套"></a>while循环嵌套</h2><blockquote>
<p>:需求:设计一个简单的钟表从00:00开始计数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"># 插入时间模块</span><br><span class="line">hour &#x3D; 0</span><br><span class="line">while hour &lt; 24:</span><br><span class="line"># 定义小时,时间上是小于24小时</span><br><span class="line">    mi &#x3D; 0</span><br><span class="line">    while mi &lt; 60:</span><br><span class="line">    # 定义分钟,小于60min</span><br><span class="line">        sec &#x3D; 0</span><br><span class="line">        while sec &lt; 60:</span><br><span class="line">            # if sec &#x3D;&#x3D; 30:</span><br><span class="line">            #     break</span><br><span class="line">            # 添加这语句之后会出现在30s跳出循环的状态</span><br><span class="line">            print( &quot;%02d:%02d:%02d&quot; % (hour,mi,sec ) )</span><br><span class="line">            sec +&#x3D; 1</span><br><span class="line">            time.sleep(1)</span><br><span class="line">            # 停顿1s 按照s的计时方式</span><br><span class="line">        mi +&#x3D; 1</span><br><span class="line">    hour +&#x3D; 1</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--互斥锁与死锁</title>
    <url>/post/dc009c11.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–互斥锁与死锁"><a href="#Python基础–互斥锁与死锁" class="headerlink" title="Python基础–互斥锁与死锁"></a>Python基础–互斥锁与死锁</h1><blockquote>
<p>在线程同时对一个全局变量写的时候,会造成资源竞争的现象,这个时候就引入到一个<code>互斥锁</code>的概念.<br> 当直接运行下面的程序的时候会出现两者的和不为200000的现象.这个就属于资源竞争.请看下先的实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"># 定义全局变量</span><br><span class="line">g_num &#x3D; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 循环一次给全局变量加1</span><br><span class="line">def sum_num1():</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        global g_num</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    print(&quot;sum1:&quot;, g_num)</span><br><span class="line"></span><br><span class="line"># 循环一次给全局变量加1</span><br><span class="line">def sum_num2():</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        global g_num</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    print(&quot;sum2:&quot;, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 创建两个线程</span><br><span class="line">    first_thread &#x3D; threading.Thread(target&#x3D;sum_num1)</span><br><span class="line">    second_thread &#x3D; threading.Thread(target&#x3D;sum_num2)</span><br><span class="line">    # 启动线程</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(g_num)</span><br></pre></td></tr></table></figure>
<h2 id="互斥锁解决资源竞争"><a href="#互斥锁解决资源竞争" class="headerlink" title="互斥锁解决资源竞争"></a>互斥锁解决资源竞争</h2><ul>
<li>互斥锁的模板<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建锁</span><br><span class="line"># lock1 是指定的对象的名字,直接使用对象的名字进行调用</span><br><span class="line">lock1 &#x3D; threading.Lock()</span><br><span class="line"># 加锁</span><br><span class="line">lock1.acquire()</span><br><span class="line"># 释放锁</span><br><span class="line">lock1.release()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="完整的解决资源竞争的互斥锁"><a href="#完整的解决资源竞争的互斥锁" class="headerlink" title="完整的解决资源竞争的互斥锁"></a>完整的解决资源竞争的互斥锁</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 具体原理这边就不做深究了,因为牵涉到了cpu运算和内存交互.</span><br><span class="line"># 代码上锁是直接添加到数据计算的层面上</span><br><span class="line"># 如果直接加到函数的前后,直接</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"># 定义全局变量</span><br><span class="line">g_num &#x3D; 0</span><br><span class="line"></span><br><span class="line"># 创建全局互斥锁</span><br><span class="line">lock &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line"># 循环一次给全局变量加1</span><br><span class="line">def sum_num1():</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        global g_num</span><br><span class="line">        lock.acquire()</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">        lock.release()</span><br><span class="line">    print(&quot;sum1:&quot;, g_num)</span><br><span class="line"></span><br><span class="line"># 循环一次给全局变量加1</span><br><span class="line">def sum_num2():</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        global g_num</span><br><span class="line">        lock.acquire()</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">        lock.release()</span><br><span class="line">    print(&quot;sum2:&quot;, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 创建两个线程</span><br><span class="line">    first_thread &#x3D; threading.Thread(target&#x3D;sum_num1)</span><br><span class="line">    second_thread &#x3D; threading.Thread(target&#x3D;sum_num2)</span><br><span class="line">    # 启动线程</span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br><span class="line">    # sleep方法是因为计算时间不大确定,所以需要等一会</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(g_num)</span><br></pre></td></tr></table></figure>
<h2 id="join方法处理互斥锁-不推荐"><a href="#join方法处理互斥锁-不推荐" class="headerlink" title="join方法处理互斥锁(不推荐)"></a>join方法处理互斥锁(不推荐)</h2><p>join 方法是相当于把多线程修改成单线程,依次执行,这样虽然也能避免资源竞争的问题,但是相对来说处理速度较慢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"># 定义全局变量</span><br><span class="line">g_num &#x3D; 0</span><br><span class="line"></span><br><span class="line"># 循环一次给全局变量加1</span><br><span class="line">def sum_num1():</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        global g_num</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    print(&quot;sum1:&quot;, g_num)</span><br><span class="line"></span><br><span class="line"># 循环一次给全局变量加1</span><br><span class="line">def sum_num2():</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        global g_num</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    print(&quot;sum2:&quot;, g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 创建两个线程</span><br><span class="line">    first_thread &#x3D; threading.Thread(target&#x3D;sum_num1)</span><br><span class="line">    second_thread &#x3D; threading.Thread(target&#x3D;sum_num2)</span><br><span class="line">    # 启动线程</span><br><span class="line">    first_thread.start()</span><br><span class="line">    first_thread.join()</span><br><span class="line">    second_thread.start()</span><br><span class="line">    second_thread.join()</span><br><span class="line">    print(g_num)</span><br></pre></td></tr></table></figure>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote>
<p>死锁是一件非常可怕的事情,一直处在堵塞状态.而造成死锁的原因就是因为使用了<code>互斥锁</code>只是直接上锁,但是却没有==释放锁==操作,具体的代码这里就不详细在写了,上面的代码中有解锁的部分,只需要直接删除任意一个解锁的操作即可实现.</p>
</blockquote>
<p>==建议大家在使用互斥锁的时候可以直接上锁和解锁一起写,就是成对的出现,最后调整解锁的位置即可,以免出现死锁,从而导致程序堵塞的现象==</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--函数版搭建简单WebServer</title>
    <url>/post/c8161b0a.html</url>
    <content><![CDATA[<h1 id="Python基础–函数版搭建简单WebServer"><a href="#Python基础–函数版搭建简单WebServer" class="headerlink" title="Python基础–函数版搭建简单WebServer"></a>Python基础–函数版搭建简单WebServer</h1><blockquote>
<p>大致代码思路如下<br>1.初始化socket<br>2.端口复用<br>3.bind端口<br>4.listen打开监听<br>5.循环接受请求<br>6.处理客户请求<br>7.发送客户请求<br>8.关闭服务客户端的端口<br>9.关闭服务端</p>
</blockquote>
<p>==Tips:这个代码是面向函数版的,之后会把面向对象的写出来,当前代码,经过了去重(重构),函数化和动静分离.所以如果有需要的可以在详细看下==</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def client_exec(client):</span><br><span class="line">    # 获取接受的数据</span><br><span class="line">    data &#x3D; client.recv(1024)</span><br><span class="line"></span><br><span class="line">    # 看看data是否有数据.有数据的时候才会处理,没数据直接退出客户端</span><br><span class="line">    if data:</span><br><span class="line">        # 对数据进行解码</span><br><span class="line">        decode_data &#x3D; data.decode(&#39;utf-8&#39;)</span><br><span class="line">        print(decode_data)</span><br><span class="line"></span><br><span class="line">        # 对获取到的数据进行切割,得到对应的访问路径</span><br><span class="line">        split_data &#x3D; decode_data.split(&#39; &#39;, maxsplit&#x3D;2)</span><br><span class="line"></span><br><span class="line">        # 异常判断,如果切割数据有异常,则直接关闭客户端.</span><br><span class="line">        # 因为服务端不清楚,是否正确获取到路径,以防客户输入有误,或者放置入侵添加异常处理</span><br><span class="line">        try:</span><br><span class="line">            file_path &#x3D; split_data[1]</span><br><span class="line">            if file_path &#x3D;&#x3D; &quot;&#x2F;&quot;:</span><br><span class="line">                file_path &#x3D; &quot;&#x2F;index.html&quot;</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;异常是 &quot;, e)</span><br><span class="line">            client.close()</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        client.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">        # 进行动静分离.目前首先以后缀名进行区分</span><br><span class="line">        # 简单区分:</span><br><span class="line">        # 动态文件: html</span><br><span class="line">        # 静态文件: 图片,音频,视频,大文本</span><br><span class="line">        # 使用函数,endswith取出后缀名进行判断</span><br><span class="line">        # 这里暂时只设置html是动态资源,其他都是静态.如果有其他需求的话,可以再添加elif进行判断.或者使用正则表达式进行比配也行</span><br><span class="line">    if file_path.endswith(&quot;.html&quot;):</span><br><span class="line"></span><br><span class="line">		# 代码重构,把指定的重复部分,添加至头部</span><br><span class="line">        reponse_line &#x3D; &quot;http&#x2F;1.1 200 OK\r\n&quot;</span><br><span class="line">        reponse_header &#x3D; &quot;&quot;</span><br><span class="line">        reponse_empty &#x3D; &#39;\r\n&#39;</span><br><span class="line">        # 根据获取的数据进行返回内容</span><br><span class="line">        if file_path &#x3D;&#x3D; &#39;&#x2F;post.html&#39;:</span><br><span class="line">			# 异常判断,打开文件,如果文件异常,返回异常信息,关闭连接</span><br><span class="line">			# 这个是对应html文件的打开,只写了一个例子,下面elif都是文本输出</span><br><span class="line">            try:</span><br><span class="line">                with open(&quot;.&#x2F;123.html&quot;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">                    reponse_body &#x3D; f.read()</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(&quot;123.html异常:&quot;, e)</span><br><span class="line">                client.close()</span><br><span class="line">                return</span><br><span class="line">                </span><br><span class="line">        elif file_path &#x3D;&#x3D; &#39;&#x2F;index.html&#39;:</span><br><span class="line">            reponse_header &#x3D; &quot;content-type:text&#x2F;html;charset&#x3D; utf-8\r\n&quot;</span><br><span class="line">            reponse_body &#x3D; &#39;你好,这个是index界面&#39;</span><br><span class="line">        else:</span><br><span class="line">	        # 设置404错误界面,如果不是匹配上面的,就直接放回404页面</span><br><span class="line">            reponse_line &#x3D; &quot;http&#x2F;1.1 404 not found\r\n&quot;</span><br><span class="line">            # 回应头,添加指定的编码信息</span><br><span class="line">            reponse_header &#x3D; &quot;content-type:text&#x2F;html;charset&#x3D; utf-8\r\n&quot;</span><br><span class="line">            # 空行</span><br><span class="line">            reponse_empty &#x3D; &quot;\r\n&quot;</span><br><span class="line">            reponse_body &#x3D; &#39;你好,这个是错误界面&#39;</span><br><span class="line">            </span><br><span class="line">        # 代码重构(去重)将冗余代码进行缩减,填写至公共部分</span><br><span class="line">        reponse_conten &#x3D; reponse_line + reponse_header + reponse_empty + reponse_body</span><br><span class="line">        client.send(reponse_conten.encode(&quot;utf-8&quot;))</span><br><span class="line">        client.close()</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        # file_path.endswith(&quot;.jpg|png|jpeg&quot;):</span><br><span class="line">        del_image(client, file_path)</span><br><span class="line"></span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def del_image(client, file_path):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    静态资源处理</span><br><span class="line">    :param client: 传参的客户端所有信息</span><br><span class="line">    :param file_path: 客户端的访问路径</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        reponse_line &#x3D; &quot;http&#x2F;1.1 200 OK \r\n&quot;</span><br><span class="line">        # 回应头</span><br><span class="line">        reponse_header &#x3D; &quot;&quot;</span><br><span class="line">        # 空行</span><br><span class="line">        reponse_empty &#x3D; &#39;\r\n&#39;</span><br><span class="line">        # 打开文件</span><br><span class="line">        with open(&#39;.%s&#39; % file_path, &quot;rb&quot;) as f:</span><br><span class="line">            creponse &#x3D; f.read()</span><br><span class="line">        reponse_conten &#x3D; reponse_line.encode(&quot;utf-8&quot;) + reponse_header.encode(&quot;utf-8&quot;) + reponse_empty.encode(</span><br><span class="line">            &quot;utf-8&quot;) + creponse</span><br><span class="line">        client.send(reponse_conten)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;错误是:&quot;, e)</span><br><span class="line">        reponse_404_html(client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def reponse_404_html(client):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    设置返回404的界面</span><br><span class="line">    :param client:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    reponse_line &#x3D; &quot;http&#x2F;1.1 404 not found\r\n&quot;</span><br><span class="line">    # 回应头</span><br><span class="line">    reponse_header &#x3D; &quot;content-type:text&#x2F;html;charset&#x3D; utf-8\r\n&quot;</span><br><span class="line">    # 空行</span><br><span class="line">    reponse_empty &#x3D; &quot;\r\n&quot;</span><br><span class="line">    reponse_body &#x3D; &#39;错误&#39;</span><br><span class="line">    reponse_conten &#x3D; reponse_line + reponse_header + reponse_empty + reponse_body</span><br><span class="line">    client.send(reponse_conten.encode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    主函数运行程序</span><br><span class="line">    :return:none</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 初始化tcp套接字</span><br><span class="line">    server_socket &#x3D; init_tcp()</span><br><span class="line"></span><br><span class="line">    # 处理客户换请求</span><br><span class="line">    del_client(server_socket)</span><br><span class="line"></span><br><span class="line">    # 关闭客户端</span><br><span class="line">    server_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def del_client(server_socket):</span><br><span class="line">    # 循环接受处理客户请求</span><br><span class="line">    while True:</span><br><span class="line">        # 获取指定的客户端信息和地址</span><br><span class="line">        client, address &#x3D; server_socket.accept()</span><br><span class="line">        print(client)</span><br><span class="line"></span><br><span class="line">        # 处理客户请求</span><br><span class="line">        client_exec(client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init_tcp():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    初始化socket,设置端口复用</span><br><span class="line">    :return: server_socket</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 初始化socket</span><br><span class="line">    server_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    # 设置端口复用</span><br><span class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</span><br><span class="line">    # bind端口</span><br><span class="line">    server_socket.bind((&#39;&#39;, 8080))</span><br><span class="line">    # 设置端口监听</span><br><span class="line">    server_socket.listen(128)</span><br><span class="line">    return server_socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--函数的使用</title>
    <url>/post/7e1a9ff3.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–函数的使用"><a href="#Python基础–函数的使用" class="headerlink" title="Python基础–函数的使用"></a>Python基础–函数的使用</h1><h2 id="函数中的变量使用"><a href="#函数中的变量使用" class="headerlink" title="函数中的变量使用"></a>函数中的变量使用</h2><blockquote>
<p>局部变量</p>
<ul>
<li>只能在函数内部使用 ,不能再函数外适用于.作用域仅限于当前的函数.类似于形参</li>
</ul>
</blockquote>
<blockquote>
<p>全局变量</p>
<ul>
<li>函数外部进行定义,作用域整个文件</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 全局变量打印和局部变量的对比</span><br><span class="line">a &#x3D; 3</span><br><span class="line">def def_nume1():</span><br><span class="line">    a &#x3D; 2</span><br><span class="line">    print(a)</span><br><span class="line">print(a)</span><br><span class="line">def_nume1()</span><br></pre></td></tr></table></figure>
<h2 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h2><p><code>在单个文件定义多个函数,之后其中一个函数运行,调用另外一个函数就是嵌套使用</code></p>
<blockquote>
<p><code>需求:</code>打印指定行,指定数量,指定符号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_line (char,lenth):</span><br><span class="line">    &quot;&quot;&quot;单行打印,允许输入指定行数和字符&quot;&quot;&quot;</span><br><span class="line">    print(char*lenth)</span><br><span class="line">    return lenth,char</span><br><span class="line"></span><br><span class="line">def max_print (line_count,char,lenth):</span><br><span class="line">    line_count &#x3D; int(input(&quot;请输入行数&quot;))</span><br><span class="line">    lenth &#x3D; int(input(&quot;请输入长度&quot;))</span><br><span class="line">    char &#x3D; input(&quot;请输入字符&quot;)</span><br><span class="line">    i &#x3D; 1</span><br><span class="line">    while i &lt;&#x3D; line_count:</span><br><span class="line">            #  进行函数的嵌套,直接调用对应的函数</span><br><span class="line">            print_line(char,lenth)</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        </span><br><span class="line">max_print(&quot;line_count&quot;,&quot;char&quot;,&quot;lenth&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--列表</title>
    <url>/post/d8ccde31.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–列表"><a href="#Python基础–列表" class="headerlink" title="Python基础–列表"></a>Python基础–列表</h1><blockquote>
<p>取出索引得数据,索引的顺序是从0开始的<br><img src="./1553001601871.png" alt="Alt text"></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [1,&quot;test&quot;,1.23]</span><br><span class="line">print(list1[1])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list2 &#x3D; [[1,&quot;a&quot;,1.2],</span><br><span class="line">         [2,&quot;b&quot;,3.4],</span><br><span class="line">         [3,&quot;c&quot;,5.6]]</span><br><span class="line">print(list2 [2][2])</span><br><span class="line"></span><br><span class="line"># 索引同时也可以直接在反向运行,最左边是&quot;-1&quot;</span><br><span class="line">print(list2 [-1][-1])</span><br><span class="line"># 超出索引范围的时候会出现错误</span><br><span class="line">print(list2[2][4])</span><br></pre></td></tr></table></figure>
<h2 id="列表的常见操作"><a href="#列表的常见操作" class="headerlink" title="列表的常见操作"></a>列表的常见操作</h2><table>
<thead>
<tr>
<th align="left">分类</th>
<th align="right">关键字/函数/方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">增加</td>
<td align="right">列表.append(值)</td>
<td align="center">在末尾追加数据</td>
</tr>
<tr>
<td align="left">删除</td>
<td align="right">列表.remove(值)</td>
<td align="center">删除第⼀个出现的指定数据</td>
</tr>
<tr>
<td align="left">修改</td>
<td align="right">列表[索引] = 值</td>
<td align="center">修改指定索引的数据，数据不存在会报错</td>
</tr>
<tr>
<td align="left">查询</td>
<td align="right">列表[索引]</td>
<td align="center">根据索引取值，索引不存在会报错</td>
</tr>
<tr>
<td align="left"></td>
<td align="right">len(列表)</td>
<td align="center">列表⻓度(元素个数)</td>
</tr>
<tr>
<td align="left"></td>
<td align="right">if 值 in 列表:</td>
<td align="center">判断列表中是否包含某个值</td>
</tr>
<tr>
<td align="left">排序</td>
<td align="right">列表.sort()</td>
<td align="center">升序排序</td>
</tr>
<tr>
<td align="left"></td>
<td align="right">列表.sort(reverse=True)</td>
<td align="center">降序排列(不支持字符集)</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [4,2,3,5,&quot;gysjfdiks&quot;]</span><br><span class="line"></span><br><span class="line">#如果需要涉及到比较的操作,必须是同类型的才能进行比较</span><br><span class="line"># print(list1)</span><br><span class="line"># # 直接对应的列表进行添加元素</span><br><span class="line">list1.append(0)</span><br><span class="line">print(list1)</span><br><span class="line"># 删除元素,删除匹配到的第一个元素,删除不存在元素会报错</span><br><span class="line">list1.remove(5)</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list1.append(0)</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list.remove( 8 )</span><br><span class="line">print(list1)</span><br><span class="line"># 修改元素值,直接对于元素赋值</span><br><span class="line">list1[4] &#x3D; 8</span><br><span class="line">print(list1)</span><br><span class="line"># 对列表进行排序</span><br><span class="line">list1.sort()   # 正向排序</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list1.sort(reverse&#x3D;True)  #排序之后并改为倒序</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list1.reverse()  # 翻转整个列表</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<h2 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h2><blockquote>
<p>语法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># for 实现列表的遍历</span><br><span class="line">for name in name_list:</span><br><span class="line">循环内部针对列表元素进⾏操作</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>场景</p>
<ul>
<li> 列表 存储相同类型的数据</li>
<li> 通过 for循环，在循环体内部，针对列表中的每⼀项元素，执⾏相同的操作</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [4,2,3,5,1]</span><br><span class="line"># 可以直接遍历整个列表的元素</span><br><span class="line"># for test in list1:</span><br><span class="line">#     print(test)</span><br><span class="line">#</span><br><span class="line"># # 根据条件进行跳出循环</span><br><span class="line">#</span><br><span class="line"># for test in list1:</span><br><span class="line">#     print(test)</span><br><span class="line">#     if test &#x3D;&#x3D; 3:</span><br><span class="line">#         print(test)</span><br><span class="line">#         break</span><br><span class="line">#         print(test)</span><br><span class="line"></span><br><span class="line"># for循环会按照索引从列表中获取元素,如果可以取出数据,并且条件成立之后,复制元素给变量,继续运行循环体</span><br><span class="line"># 可以使用break 或者continue 进行直接循环中断判断</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="遍历中的bug"><a href="#遍历中的bug" class="headerlink" title="遍历中的bug"></a>遍历中的bug</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># for num in list1:</span><br><span class="line"># #    print( num )</span><br><span class="line">#     if num &#x3D;&#x3D; 3 :</span><br><span class="line">#         list1.remove(num)</span><br><span class="line">#     print( num )</span><br><span class="line"># # 不能遍历所有元素,查了一个元素5.需要单独在创建一个历史列表,进行单独删除</span><br><span class="line"></span><br><span class="line">tmp_list &#x3D; []</span><br><span class="line">for num in list1:</span><br><span class="line">    if num &#x3D;&#x3D; 3:</span><br><span class="line">        tmp_list.append(num)</span><br><span class="line">    print(tmp_list)</span><br><span class="line">for num in tmp_list:</span><br><span class="line">    list1.remove(num)</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<h1 id="姓名管理系统-遍历"><a href="#姓名管理系统-遍历" class="headerlink" title="姓名管理系统(遍历)"></a>姓名管理系统(遍历)</h1><blockquote>
<p>需求: </p>
<ul>
<li>开发姓名管理系统, 完成添加姓名、删除姓名、显示全部姓名功能,输入其他报错</li>
<li>包含退出程序功能</li>
<li>删除无数据显示无数据</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_name &#x3D; []</span><br><span class="line">while True:</span><br><span class="line">    num &#x3D; input( &quot;请输入操作的编号: 1.增加姓名 2.删除姓名 3.显示全部姓名 4.退出程序:&quot; )</span><br><span class="line">    if num &#x3D;&#x3D; &quot;1&quot;:</span><br><span class="line">        name &#x3D; input( &quot;请输入增加的姓名:&quot;)</span><br><span class="line">        list_name.append(name)</span><br><span class="line">        print(&quot;添加成功&quot;)</span><br><span class="line">    elif num &#x3D;&#x3D; &quot;2&quot;:</span><br><span class="line">        name &#x3D; input(&quot;请输入删除的姓名:&quot;)</span><br><span class="line">        if name in list_name:</span><br><span class="line">            list_name.remove(name)</span><br><span class="line">            print(&quot;删除成功&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;姓名不存在&quot;)</span><br><span class="line">    elif num &#x3D;&#x3D; &quot;3&quot;:</span><br><span class="line">        print(&quot;所有姓名如下&quot;)</span><br><span class="line">        # 赋值一个空的字符串,进行遍历累加,最终输出</span><br><span class="line">        b &#x3D; &quot; &quot;</span><br><span class="line">        for i in list_name:</span><br><span class="line">            b +&#x3D; i + &quot; &quot;</span><br><span class="line">        print(b)</span><br><span class="line">    elif num &#x3D;&#x3D; &quot;4&quot; :</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;输入错误,请重新输入&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--匿名函数</title>
    <url>/post/feb102b9.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–匿名函数"><a href="#Python基础–匿名函数" class="headerlink" title="Python基础–匿名函数"></a>Python基础–匿名函数</h1><blockquote>
<p>调用匿名参数进行运算<br>定义匿名函数  没有名字的匿名函数(以表达式的形式来定义的简单函数)</p>
</blockquote>
<p>==匿名函数格式:   lambda 参数1,参数2:返回值()==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义一个函数求num1和num2的和</span><br><span class="line">def sum_fun(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plus &#x3D; sum_fun(1, 2)</span><br><span class="line">print(plus)</span><br><span class="line"></span><br><span class="line"># 直接打印指定的匿名函数</span><br><span class="line"># 函数内容为num1和num2求和,后面括号的1和2,分别是num1和num2的值</span><br><span class="line">plus1 &#x3D; (lambda num1, num2: num1 + num2)(1, 2)</span><br><span class="line">print(plus1)</span><br><span class="line"></span><br><span class="line"># 直接定义匿名函数,并且返回指定num1和num2的和</span><br><span class="line">def sum_fun1(num1, num2):</span><br><span class="line">    return lambda: num1 + num2</span><br><span class="line">    # 这个地方的加法,适用于算术运算符,可以自行改动调试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plus2 &#x3D; sum_fun(1, 2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--参数定义</title>
    <url>/post/d6037639.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–参数定义"><a href="#Python基础–参数定义" class="headerlink" title="Python基础–参数定义"></a>Python基础–参数定义</h1><ul>
<li><code>argument</code>实参 位置参数,关键字实参</li>
<li><code>parameter</code> 形参  默认形参  可变形参,不可变形参</li>
</ul>
<h2 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a>位置实参</h2><blockquote>
<p>普通的实参  按照参数的顺序把数据传递给形参</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sum_fun(num1,num2):</span><br><span class="line">    plus &#x3D; num1*num2</span><br><span class="line">    print(&quot;两个数字的乘积&#x3D;%s&quot; % plus)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 位置实参是把下面调用的数据直接传递到函数里面</span><br><span class="line">sum_fun(2, 3)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键字参数 可以指定对应的形参<br><code>关键字实参必须在位置参数后面,否则会出现报错</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test_fun(num1,num2):</span><br><span class="line">    print(num1)</span><br><span class="line">    print(num2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 指定对应的关键字参数 num1&#x3D;3   num2&#x3D; 4</span><br><span class="line">test_fun(num1&#x3D;3,num2&#x3D;4)</span><br></pre></td></tr></table></figure>
<h2 id="默认形参"><a href="#默认形参" class="headerlink" title="默认形参"></a>默认形参</h2><p><code>给形参设置的默认值,如果设置实参,就会使用实参.如果不设置实参,就会使用默认形参</code></p>
<ul>
<li><p>默认形参必须在普通形参后面</p>
<blockquote>
<p>正确使用默认形参</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test_fun(num1,num2&#x3D;10):</span><br><span class="line">    print(num1)</span><br><span class="line">    print(num2)</span><br><span class="line">test_fun(2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不正确使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test_fun(num1&#x3D;1,num2):</span><br><span class="line">    print(num1)</span><br><span class="line">    print(num2)</span><br><span class="line">test_fun(2)</span><br></pre></td></tr></table></figure>
<h2 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h2></li>
<li><p>元组型可变形参  可以接受任意数量的位置参数,一般在形参列表末尾</p>
</li>
<li><p>字典型可变形参</p>
</li>
</ul>
<h3 id="元组型可变形参"><a href="#元组型可变形参" class="headerlink" title="元组型可变形参"></a>元组型可变形参</h3><blockquote>
<p>给形参前面添加<code>*</code>,标志其为元组可变形参<br>传进来的任意位置参数会被包装成为元组,随后赋值给args</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def args_fun(*args):</span><br><span class="line">    sum_plus &#x3D; 0</span><br><span class="line">    for i in args:</span><br><span class="line">        sum_plus +&#x3D; i</span><br><span class="line">    print(sum_plus)</span><br><span class="line"></span><br><span class="line"># 传递多个参数到定义的函数内部</span><br><span class="line">args_fun(1, 2, 23, 4)</span><br></pre></td></tr></table></figure>
<h3 id="字典型可变形参"><a href="#字典型可变形参" class="headerlink" title="字典型可变形参"></a>字典型可变形参</h3><blockquote>
<p>给形参前面添加<code>**</code>,标志其为字典型可变形参,传进来的任意位置参数会被包装成为字典,随后赋值给args</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def stu_info_fun(**kwargs):</span><br><span class="line">    name &#x3D; kwargs.get(&quot;name&quot;, &quot;暂无&quot;)</span><br><span class="line">    age &#x3D; kwargs.get(&quot;age&quot;, &quot;暂无&quot;)</span><br><span class="line">    weight &#x3D; kwargs.get(&quot;weight&quot;, &quot;暂无&quot;)</span><br><span class="line">    print(&quot;姓名:%s,年龄:%s,体重:%s&quot; % (name,age,weight))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu_info_fun(name&#x3D;&#39;王&#39;, age&#x3D;19, weight&#x3D;140) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--变量</title>
    <url>/post/55994e0f.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–变量"><a href="#Python基础–变量" class="headerlink" title="Python基础–变量"></a>Python基础–变量</h1><ul>
<li><p>在python,重复赋值同一变量的时候会出现覆盖的现象</p>
</li>
<li><p>等号(<code>=</code>)赋值符号</p>
</li>
<li><p>左边变量名字,右边需要赋的值</p>
<blockquote>
<p>变量名 = 值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#定义变量</span><br><span class="line">price &#x3D; 8.5</span><br><span class="line">weight &#x3D; 7.5</span><br><span class="line"># 计算总价</span><br><span class="line">total &#x3D; price * weight</span><br><span class="line"># 总价格减少10元</span><br><span class="line">total &#x3D; total - 10</span><br><span class="line"># 最后输出总价</span><br><span class="line">print ( total )</span><br></pre></td></tr></table></figure>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 变量类型不需要直接设置,由程序自动给出</span><br><span class="line">name &#x3D; &quot;张三&quot;    	# 字符串str 记录文本类型</span><br><span class="line">age &#x3D; 20            # int 整型 记录整数</span><br><span class="line">wheight &#x3D; 65</span><br><span class="line">hight &#x3D; 1.70        # float 浮点型 记录带有小数点的数字</span><br><span class="line">gender &#x3D; True       # bool型  非真及假  只有两种类型  true 和 false</span><br><span class="line"></span><br><span class="line"># 查看变量的类型       &quot;type&quot;(变量)</span><br><span class="line">print (&quot;--------------&quot;)</span><br><span class="line">print ( type ( name ) )</span><br><span class="line">print ( type ( age ) )</span><br><span class="line">print ( type ( hight ) )</span><br><span class="line">print ( type ( gender ) )</span><br></pre></td></tr></table></figure>
<p>上面的例子中是包含了一些简单的类型.</p>
<blockquote>
<p>Ps:<code>python</code>中定义变量是不需要指定类型</p>
</blockquote>
<h2 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h2></li>
<li><p>数字型</p>
<ul>
<li>整型( int )</li>
<li>浮点型( float )</li>
<li>布尔型( bool )<ul>
<li>真 True( 数字运算时表示1 ) </li>
<li>假 False( 数字运算是表示0 )</li>
</ul>
</li>
<li>复数型( complex )<ul>
<li>科学计算( 场,波动,电感电容 )</li>
</ul>
</li>
</ul>
</li>
<li><p>非数字型</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元数组</li>
<li>字典<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用&#96;type&#96;可以查看变量类型</span><br><span class="line">print ( type ( name ) )</span><br></pre></td></tr></table></figure>
<h1 id="变量的计算"><a href="#变量的计算" class="headerlink" title="变量的计算"></a>变量的计算</h1><h2 id="数字变量的计算"><a href="#数字变量的计算" class="headerlink" title="数字变量的计算"></a>数字变量的计算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数字变量可以直接参与运算</span><br><span class="line">a &#x3D; 10</span><br><span class="line">b &#x3D; 3</span><br><span class="line">c &#x3D; True                #数学运算当做1</span><br><span class="line">d &#x3D; False               # 数学运算是当做0</span><br><span class="line">print ( a + b )</span><br><span class="line">print ( a + c )</span><br><span class="line">print ( b + d )</span><br></pre></td></tr></table></figure>
<h2 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 字符串之间表示相加</span><br><span class="line">first_name &#x3D; &quot;chen&quot;</span><br><span class="line">last_name &#x3D; &quot;ming&quot;</span><br><span class="line">full_name &#x3D; first_name + last_name</span><br><span class="line">print  ( full_name )</span><br><span class="line"># 字符串 * 整数 &#x3D;&#x3D; 多次字符串的重复出现 整数代表次数</span><br><span class="line">test_name &#x3D; full_name * 5</span><br><span class="line">print ( test_name )</span><br><span class="line"></span><br><span class="line"># 以上是所有运算,字符串不能在参加其他运算</span><br><span class="line">test_name1 &#x3D; first_name + 5</span><br><span class="line">print ( test_name1 )</span><br><span class="line"># 以上结果会出现运行报错</span><br></pre></td></tr></table></figure>
<h1 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2></li>
</ul>
</li>
<li><p>标示符可以由字⺟,下划线和数字组成</p>
</li>
<li><p>不能以数字开头</p>
</li>
<li><p>不能与关键字重名</p>
</li>
<li><p>严格区分大小写 <code>test ≠ Test</code></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2></li>
<li><p>已经在最初被定义的特殊字符</p>
</li>
<li><p> 具有特殊含义和功能</p>
</li>
<li><p> 开发者不允许</p>
</li>
</ul>
<h3 id="查看关键字"><a href="#查看关键字" class="headerlink" title="查看关键字"></a>查看关键字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import keyword</span><br><span class="line">print ( keyword.kwlist)</span><br><span class="line"># 以下为输出的关键字( python 3.6 )</span><br><span class="line">[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</span><br></pre></td></tr></table></figure>
<h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><ul>
<li>单个单词时可以使用小写字母</li>
<li>多个单词之前可以使用<code>_</code>连接<blockquote>
<p>驼峰命名法( 多个单词拼接 )</p>
<ul>
<li>小驼峰( 首字母小写,中间第二个单词首字母起是大写    <code>firstName</code>)</li>
<li>大驼峰法则( 首字母大写,中间第二个单词首字母也是大写     <code> FirstName</code>)</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--名片管理系统</title>
    <url>/post/a7b6296e.html</url>
    <content><![CDATA[<h1 id="Python基础–名片管理系统"><a href="#Python基础–名片管理系统" class="headerlink" title="Python基础–名片管理系统"></a>Python基础–名片管理系统</h1><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><blockquote>
<p>代码分为两个文件,main.py和tools.py,main是主干,tools是定义的函数,进行导入<br>tools 是自己定义的一个模块,里面写了较多的函数<br>为了减少主代码的臃肿和方便后期添加功能<br>因为是直接使用makdown书写的博文,所以有可能代码在注释的地方会出现缩进上的问题,可以稍微改下,麻烦了</p>
</blockquote>
<a id="more"></a>
<h2 id="代码实现功能"><a href="#代码实现功能" class="headerlink" title="代码实现功能"></a>代码实现功能</h2><ul>
<li>根据用户的输入选择不同的功能</li>
<li>记录用户的姓名和年龄</li>
<li>查询名片的时候可以删除或者修改对应信息<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2></li>
<li>主程序</li>
<li> 添加功能模块</li>
<li> 将功能模块导入主程序</li>
<li> 调试bug<h2 id="main文件代码"><a href="#main文件代码" class="headerlink" title="main文件代码"></a>main文件代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tools</span><br><span class="line"># 导入tools模块文件</span><br><span class="line">while True:</span><br><span class="line">    tools.max_print(1, &quot;*&quot;, 20)</span><br><span class="line">    tools.prin_fun()</span><br><span class="line">    tools.max_print(1, &quot;*&quot;, 20)</span><br><span class="line">    cz_num&#x3D;input(&quot;请选择执行的操作:&quot;)</span><br><span class="line">    if cz_num &#x3D;&#x3D; &quot;1&quot;:</span><br><span class="line">        tools.add_card()</span><br><span class="line">    elif cz_num &#x3D;&#x3D; &quot;2&quot;:</span><br><span class="line">        print(&quot;您选择的功能:2&quot;)</span><br><span class="line">        print(&quot;功能: 显示全部&quot;)</span><br><span class="line">        tools.show_alllist()</span><br><span class="line">    elif cz_num &#x3D;&#x3D; &quot;3&quot;:</span><br><span class="line">        print(&quot;您选择的功能:3&quot;)</span><br><span class="line">        print(&quot;功能: 查询名片&quot;)</span><br><span class="line">        tools.search_name()</span><br><span class="line">    elif cz_num &#x3D;&#x3D; &quot;0&quot;:</span><br><span class="line">        print(&quot;您选择的功能:0&quot;)</span><br><span class="line">        print(&quot;欢迎再次使用[姓名管理系统]&quot;)</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;输入有误,请重新输入&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="tools文件代码"><a href="#tools文件代码" class="headerlink" title="tools文件代码"></a>tools文件代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义全局变量,用于存储姓名信息的列表</span><br><span class="line">card_info &#x3D; [] </span><br><span class="line"></span><br><span class="line"># &#96;print_line()&#96;和&#96;max_print()&#96;函数是之前随便写的一个函数,刚好拿来用,功能是输出指定行数的特殊符号</span><br><span class="line">def print_line(char, w_lenth):</span><br><span class="line">    &quot;&quot;&quot;单行打印,允许输入指定行数和字符&quot;&quot;&quot;</span><br><span class="line">    print(char * w_lenth)</span><br><span class="line">    return w_lenth, char</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def max_print(line_count, char, w_lenth):</span><br><span class="line">    i &#x3D; 1</span><br><span class="line">    while i &lt;&#x3D; line_count:</span><br><span class="line">        #  进行函数的嵌套,直接调用对应的函数</span><br><span class="line">        print_line(char, w_lenth)</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def prin_fun():</span><br><span class="line">	&quot;&quot;&quot;进入程序的显示界面&quot;&quot;&quot;</span><br><span class="line">    print(&quot;欢迎使用[姓名管理系统]&quot;)</span><br><span class="line">    print()</span><br><span class="line">    print(&quot;1.新建名片&quot;)</span><br><span class="line">    print(&quot;2.显示全部&quot;)</span><br><span class="line">    print(&quot;3.查询名片&quot;)</span><br><span class="line">    print()</span><br><span class="line">    print(&quot;0.退出系统&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_card():</span><br><span class="line">	&quot;&quot;&quot;新建名片&quot;&quot;&quot;</span><br><span class="line">    print(&quot;您选择的功能:1&quot;)</span><br><span class="line">    print(&quot;功能: 新建名片&quot;)</span><br><span class="line">    name_str &#x3D; input(&quot;请输入姓名:&quot;)</span><br><span class="line">    # 定义姓名的字符串进行传参判断是否姓名存在</span><br><span class="line">    for card_dict in card_info:</span><br><span class="line">        if name_str &#x3D;&#x3D; card_dict[&quot;name&quot;]:</span><br><span class="line">            print(&quot;姓名存在,请重新输入&quot;)</span><br><span class="line">            break</span><br><span class="line">    age_str &#x3D; input(&quot;请输入年龄:&quot;)</span><br><span class="line">    card_dict &#x3D; &#123;&quot;name&quot;: name_str, &quot;age&quot;: age_str&#125;</span><br><span class="line">    card_info.append(card_dict)</span><br><span class="line">    print(card_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_alllist():</span><br><span class="line">	&quot;&quot;&quot;显示名片所有信息&quot;&quot;&quot;</span><br><span class="line">    print(&quot;您选择的功能:2&quot;)</span><br><span class="line">    print(&quot;功能: 显示全部&quot;)</span><br><span class="line">    print(&quot;显示所有信息&quot;)</span><br><span class="line">    # 判断列表是否有数据,无数据进行返回无信息</span><br><span class="line">    if len(card_info) &#x3D;&#x3D; 0:</span><br><span class="line">        print(&quot;本表内无信息,请您添加信息&quot;)</span><br><span class="line">        return</span><br><span class="line">	# 显示表头函数</span><br><span class="line">    show_table_head()</span><br><span class="line">    # 变量整个列表,逐个输出当前程序存储的所有信息</span><br><span class="line">    for i in card_info:</span><br><span class="line">        print(&quot;%s\t\t%s&quot; % (i[&quot;name&quot;], i[&quot;age&quot;]))</span><br><span class="line">    print(&quot;-&quot; * 30)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_table_head():</span><br><span class="line">    &quot;&quot;&quot;显示表头&quot;&quot;&quot;</span><br><span class="line">    print(&quot;姓名\t\t年龄&quot;)</span><br><span class="line">    print(&quot;-&quot; * 30)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def search_name():</span><br><span class="line">	&quot;&quot;&quot;查询名片功能&quot;&quot;&quot;</span><br><span class="line">    print(&quot;您选择的功能:3&quot;)</span><br><span class="line">    print(&quot;功能: 查询名片&quot;)</span><br><span class="line">    print(&quot;查询名片&quot;)</span><br><span class="line">    sea_name &#x3D; input(&quot;请输入查询的名字&quot;)</span><br><span class="line">    # 根据上面传参进行遍历比对,如果有信息就输出对应信息,否则返回无此姓名</span><br><span class="line">    for i in card_info:</span><br><span class="line">        if sea_name &#x3D;&#x3D; i[&quot;name&quot;]:</span><br><span class="line">            show_table_head()</span><br><span class="line">            print(&quot;%s\t\t%s&quot; % (i[&quot;name&quot;], i[&quot;age&quot;]))</span><br><span class="line">            print(&quot;-&quot; * 30)</span><br><span class="line"></span><br><span class="line">            fix_card(i)</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;未找到信息%s&quot; % sea_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fix_card(card):</span><br><span class="line">	&quot;&quot;&quot;查询到姓名之后可以修改的功能&quot;&quot;&quot;</span><br><span class="line">    while True:</span><br><span class="line">        cmd_num &#x3D; input(&quot;请输入操作:1.修改&#x2F;2.删除&#x2F;0.退出&quot;)</span><br><span class="line">        if cmd_num &#x3D;&#x3D; &quot;1&quot;:</span><br><span class="line">            print(card)</span><br><span class="line">            card[&quot;name&quot;] &#x3D; input(&quot;请输入您更新的名字&quot;)</span><br><span class="line">            card[&quot;age&quot;]  &#x3D; input(&quot;请输入您更新的年龄&quot;)</span><br><span class="line">            print(card)</span><br><span class="line">            print(&quot;更新成功&quot;)</span><br><span class="line">            break</span><br><span class="line">        elif cmd_num &#x3D;&#x3D; &quot;2&quot;:</span><br><span class="line">            card_info.remove(card)</span><br><span class="line">            print(&quot;删除成功&quot;)</span><br><span class="line">        elif cmd_num &#x3D;&#x3D; &quot;0&quot;:</span><br><span class="line">            print(&quot;您选择退出&quot;)</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;输入错误,请重新输入&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--多态</title>
    <url>/post/ea24646c.html</url>
    <content><![CDATA[<h1 id="Python基础–多态"><a href="#Python基础–多态" class="headerlink" title="Python基础–多态"></a>Python基础–多态</h1><ul>
<li>多态:同类对象的多种形态</li>
<li>实现多态的步骤<ul>
<li>定义新的子类</li>
<li>重写对应的父类方法</li>
<li>使用子类的方法直接处理,不调用父类的方法</li>
</ul>
</li>
</ul>
<p>==person是父类,内置了paly和dance的方法,但是OldMan和YouMan这两个子类不想要去调用父类Person的dance方法,需要执行自己的同名dance方法,这个就被称作是==<code>多态</code></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def dance(self):</span><br><span class="line">        print(&quot;我是大侠,就要舞剑&quot;)</span><br><span class="line"></span><br><span class="line">    def play(self):</span><br><span class="line">        print(&quot;普通的disc&quot;)</span><br><span class="line">        self.dance()</span><br><span class="line">        print(&quot;普通的摇摆&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OldMan(Person):</span><br><span class="line">    def dance(self):</span><br><span class="line">        print(&quot;我是老年人,喜欢广播体操&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class YouMan(Person):</span><br><span class="line">    def dance(self):</span><br><span class="line">        print(&quot;我是年轻人就喜欢跑酷&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">daxia &#x3D; Person()</span><br><span class="line">daxia.play()</span><br><span class="line"></span><br><span class="line">laowang &#x3D; OldMan()</span><br><span class="line">laowang.play()</span><br><span class="line"></span><br><span class="line">xiaozhang &#x3D; YouMan()</span><br><span class="line">xiaozhang.play()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--多继承</title>
    <url>/post/71a2a13.html</url>
    <content><![CDATA[<h1 id="Python基础–多继承"><a href="#Python基础–多继承" class="headerlink" title="Python基础–多继承"></a>Python基础–多继承</h1><p><code>MRO</code>（Method Resolution Order）：方法解析顺序</p>
<ul>
<li>在多继承中<code>MRO</code> 是被经常使用到的方法,因为牵涉到多继承的问题,不清楚到的最下面的子类继承的父类的顺序是什么,.这个是使用MRO就能准确直观的看到继承的顺序了<blockquote>
<p>格式为: <code>class 类名(父类1,父类2)</code></p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义父类Cat</span><br><span class="line">class Cat:</span><br><span class="line">    def bark(self):</span><br><span class="line">        &quot;&quot;&quot; 小猫叫&quot;&quot;&quot;</span><br><span class="line">        print(&quot;喵喵&quot;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        &quot;&quot;&quot;食物&quot;&quot;&quot;</span><br><span class="line">        print(&quot;猫粮&quot;)</span><br><span class="line"></span><br><span class="line"># 定义父类God</span><br><span class="line">class God:</span><br><span class="line">    def fly(self):</span><br><span class="line">        &quot;&quot;&quot;飞翔&quot;&quot;&quot;</span><br><span class="line">        print(&quot;飘啊飘啊&quot;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        &quot;&quot;&quot;没啥吃的,舔爪子&quot;&quot;&quot;</span><br><span class="line">        print(&quot;舔爪子&quot;)</span><br><span class="line"></span><br><span class="line"># 定义多继承类FlyCat</span><br><span class="line"># &#96;PS&#96;注意格式</span><br><span class="line">class FlyCat(Cat, God):</span><br><span class="line">    # 多继承 ,逗号隔开,继承多个类的方法和属性</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dalianmao &#x3D; FlyCat()</span><br><span class="line">dalianmao.eat()</span><br><span class="line">dalianmao.bark()</span><br><span class="line">dalianmao.fly()</span><br><span class="line"></span><br><span class="line">print(FlyCat.__mro__)</span><br><span class="line"></span><br><span class="line"># print(FlyCat.__mro__)的输出为:</span><br><span class="line">(&lt;class &#39;__main__.FlyCat&#39;&gt;, &lt;class &#39;__main__.Cat&#39;&gt;, &lt;class &#39;__main__.God&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span><br><span class="line"></span><br><span class="line"># 根据mro的输出顺序,可以看到,对应的继承顺序为FlyCat--&gt; Cat --&gt; God --&gt; object(基类)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--字符串</title>
    <url>/post/a896d36e.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–字符串"><a href="#Python基础–字符串" class="headerlink" title="Python基础–字符串"></a>Python基础–字符串</h1><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><blockquote>
<p> 判断全部否是字母</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; &quot;Helloween&quot;</span><br><span class="line">if str.isalpha():</span><br><span class="line">    print(&quot;字母&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断全部否是数字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; &quot;1234&quot;</span><br><span class="line">if str.isdecimal() :</span><br><span class="line">    print(&quot;数字&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断都是大写</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; &quot;ABC&quot;</span><br><span class="line">if str.isupper():</span><br><span class="line">    print(&quot;大写&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断都是小写</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; &quot;abc&quot;</span><br><span class="line">if str.lower():</span><br><span class="line">    print(&quot;小写&quot;)</span><br><span class="line">str &#x3D; &quot;Helloween&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指定字符开头</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if str.startswith(&quot;H&quot;):</span><br><span class="line">    print(&quot;属于指定开头&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 指定字符结尾</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if str.endswith(&quot;en&quot;):</span><br><span class="line">    print(&quot;属于指定结尾&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;不属于&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大小写转换</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str2 &#x3D; str.upper()</span><br><span class="line">print (str2)</span><br><span class="line">str3 &#x3D; str.lower()</span><br><span class="line">print(str3)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对齐使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量.center(内容宽度,填充字符)</span><br><span class="line"># 居中对齐</span><br><span class="line">str2 &#x3D; str.center(20,&quot;@&quot;)</span><br><span class="line">print(str2)</span><br><span class="line"># 左对齐  left</span><br><span class="line">str1 &#x3D; str.ljust(20,&quot;@&quot;)</span><br><span class="line">print(str1)</span><br><span class="line"># 右对齐 right</span><br><span class="line">str1 &#x3D; str.rjust(20,&quot;@&quot;)</span><br><span class="line">print(str1)</span><br><span class="line"></span><br><span class="line"># 去除两端内容   变量.strip(&quot;指定字符&quot;)  默认为空白字符</span><br><span class="line">str3 &#x3D; str2.strip(&quot;@&quot;)</span><br><span class="line">print(str3)</span><br><span class="line"></span><br><span class="line"># 自动匹配所有并且替换指定字符</span><br><span class="line">str4 &#x3D; &quot;^&amp;*JkGY^&amp;^*&amp;(&quot;</span><br><span class="line">str5 &#x3D; str4.replace(&quot;^&quot;, &quot;11&quot;)</span><br><span class="line">print(str5) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--定义简单函数</title>
    <url>/post/2604c2fb.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–定义简单函数"><a href="#Python基础–定义简单函数" class="headerlink" title="Python基础–定义简单函数"></a>Python基础–定义简单函数</h1><blockquote>
<p><code>函数</code>: 可以将具有独立功能的一段代码包装成一个整体</p>
<ul>
<li>首先,需要定义函数</li>
<li>然后,调用对应的函数,执行包装起来的main程序<br><code>格式如下</code></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一般我们都会在定义函数的时候,在函数整体的上面和下面分别多出两个空行,以便突出函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def 函数名():</span><br><span class="line">	&quot;&quot;&quot;函数文档,可以不添加,但是为了代码的易读性,尽量添加,简单说明本函数的功能性和参数的含义&quot;&quot;</span><br><span class="line">	#代码具体内容</span><br><span class="line">	return  # 是返回函数值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用函数</span><br><span class="line">函数名()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下为以一个简单的哈数调用的实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sum_fun(num1,num2):</span><br><span class="line">    num1 &#x3D; int(input(&quot;请输入第一个数字:&quot;))</span><br><span class="line">    num2 &#x3D; int(input(&quot;请输入第二个数字:&quot;))</span><br><span class="line">    plus &#x3D; num1*num2</span><br><span class="line">    print(&quot;两个数字的乘积位%s&quot; % plus)</span><br><span class="line">    return plus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum_fun(&quot;num1&quot;, &quot;num2&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--局部变量和全局变量</title>
    <url>/post/4fb447b5.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–局部变量和全局变量"><a href="#Python基础–局部变量和全局变量" class="headerlink" title="Python基础–局部变量和全局变量"></a>Python基础–局部变量和全局变量</h1><ul>
<li>局部变量  只能在函数内部使用,不能再函数外使用作用域当前函数</li>
<li>全局变量  函数内部和形参相同,作用域整个文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义全局变量a&#x3D;3</span><br><span class="line">a &#x3D; 3</span><br><span class="line"># 定义函数num1 内部传参a&#x3D;2,最后打印</span><br><span class="line">def num1():</span><br><span class="line">    a &#x3D; 2</span><br><span class="line">    print(a)</span><br><span class="line">print(a)</span><br><span class="line">num1()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果是不一致的,这个例子很好的说明了局部变量和全局变量的差别</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--异常传递</title>
    <url>/post/cd498686.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–异常传递"><a href="#Python基础–异常传递" class="headerlink" title="Python基础–异常传递"></a>Python基础–异常传递</h1><blockquote>
<p>try 嵌套是,如果内层的except不能捕获到异常,会把异常传递给外层的except<br>如果还无法捕获,就会继续传递,知道无法传达报错</p>
</blockquote>
<h2 id="try的嵌套-传递异常"><a href="#try的嵌套-传递异常" class="headerlink" title="try的嵌套,传递异常"></a>try的嵌套,传递异常</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&quot;123&quot;)</span><br><span class="line">    try:</span><br><span class="line">        print(a)</span><br><span class="line">    except FileExistsError:</span><br><span class="line">        print(&quot;文件存在报错&quot;)</span><br><span class="line">except BaseException:</span><br><span class="line">    print(&quot;程序内部出现异常&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="try嵌套但是最外层异常"><a href="#try嵌套但是最外层异常" class="headerlink" title="try嵌套但是最外层异常"></a>try嵌套但是最外层异常</h2><blockquote>
<p>这个实例是直接报错,没有后续执行被except捕获直接打印</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(a)</span><br><span class="line">    try:</span><br><span class="line">        print(&quot;a&quot;)</span><br><span class="line">    except FileExistsError:</span><br><span class="line">        print(&quot;文件存在报错&quot;)</span><br><span class="line">except BaseException:</span><br><span class="line">    print(&quot;程序内部出现异常&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--异常处理</title>
    <url>/post/23535a2f.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–异常处理"><a href="#Python基础–异常处理" class="headerlink" title="Python基础–异常处理"></a>Python基础–异常处理</h1><blockquote>
<p>作用<br>避免程序报错,提高程序的稳定性<br>获取报错信息<br>多用于可以预判的错误进行提前处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 具体的模板</span><br><span class="line"># try  是尝试处理缩进里面的所有内容,报错后,会执行execpt的内容</span><br><span class="line">try:</span><br><span class="line">	尝试执行内容</span><br><span class="line">except:</span><br><span class="line">	指定输出错误信息</span><br></pre></td></tr></table></figure>
<blockquote>
<p>具体的实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    with open(&quot;file&quot;) as f:</span><br><span class="line">        content &#x3D; f.read()</span><br><span class="line">        print(content)</span><br><span class="line">except FileNotFoundError:</span><br><span class="line">    # 捕获指定类型的错误</span><br><span class="line">    print(&quot;你输错了哇&quot;)</span><br><span class="line">print(&quot;我到底执不执行呢?&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="Exception使用"><a href="#Exception使用" class="headerlink" title="Exception使用"></a>Exception使用</h2><ul>
<li>BaseException是所有类型的报错信息的基类</li>
<li>Exception是常见类的报错信息</li>
<li>error 会接受具体的报错信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    with open(&quot;file&quot;) as f:</span><br><span class="line">        content &#x3D; f.read()</span><br><span class="line">        print(content)</span><br><span class="line">except BaseException as error:</span><br><span class="line">    # BaseException是所有类型的报错信息的基类</span><br><span class="line">    # Exception是常见类的报错信息</span><br><span class="line">    # error 会接受具体的报错信息</span><br><span class="line">    print(&quot;报错信息是:%s&quot; % error)</span><br><span class="line">print(&quot;我到底执不执行呢?&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="try中else和finally的使用"><a href="#try中else和finally的使用" class="headerlink" title="try中else和finally的使用"></a>try中else和finally的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    # with open(&quot;file&quot;) as f:</span><br><span class="line">    #     content &#x3D; f.read()</span><br><span class="line">    #     print(content)</span><br><span class="line">    # print(&quot;a&quot;)</span><br><span class="line">    f &#x3D; open(&quot;a.txt&quot;)</span><br><span class="line">    content &#x3D; f.read(f)</span><br><span class="line">except BaseException as error:</span><br><span class="line">    print(&quot;报错信息是:%s&quot; % error)</span><br><span class="line">else:</span><br><span class="line"># 尝试执行的代码没有对应的错误就会直接运行else里面的代码</span><br><span class="line">    print(&quot;你没有错,可以运行&quot;)</span><br><span class="line">finally:</span><br><span class="line"># finally的代码  无论是否错误缩进的内容都会被打印的</span><br><span class="line">    print(&quot;我是不管错误不错都会出来的&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--引用</title>
    <url>/post/8f098d77.html</url>
    <content><![CDATA[<h1 id="Python基础–引用"><a href="#Python基础–引用" class="headerlink" title="Python基础–引用"></a>Python基础–引用</h1><p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<blockquote>
<p><code>id</code>返回引用地址,如果引用是相同的,代表指向同一地址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; a</span><br><span class="line"># 引用传递,将a&#x3D;1的地址返回给了b</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<p>==打印出来id的信息是一样的。python在执行对应的程序的时候,会把数字和字符串放置到内存中,<br>如果数据已经被写入之后,再次调用的时候会直接读取对应的地址,如果不存在,才会开辟新的空间进行存储数据==</p>
<blockquote>
<p>如下:实例中a被修改了数据,重新指向了c存储数据的地址,但是,因为b仍然指向原来的数据地址,所以a的数据改变但是b的数据没有改变</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [1]</span><br><span class="line">b &#x3D; a</span><br><span class="line">a.append(2)</span><br><span class="line">c &#x3D; [11, 22]</span><br><span class="line">a &#x3D; c</span><br><span class="line">print(a), print(id(a))</span><br><span class="line">print(b), print(id(b))</span><br><span class="line">print(c), print(id(c))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--搬家具(面向对象)</title>
    <url>/post/437ef874.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–搬家具-面向对象"><a href="#Python基础–搬家具-面向对象" class="headerlink" title="Python基础–搬家具(面向对象)"></a>Python基础–搬家具(面向对象)</h1><blockquote>
<p>需求: 定义房子的地点,面积,然后往房子里面放家具<br>定义家具的面积,如果房子面积大于家具的面积,仍然可以放家具<br>需要返回家具的自身类型和面积大小<br>需要返回房子的面积,地址和剩余面积</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义家具类</span><br><span class="line">class JiaJu:</span><br><span class="line">	# 初始化魔法方法,定义家具的类型和面积</span><br><span class="line">    def __init__(self, type, area):</span><br><span class="line">        self.type &#x3D; type</span><br><span class="line">        self.area &#x3D; area</span><br><span class="line">	# 使用str魔法方法返回指定输出</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;家具的类型是:%s 家具的面积是:%s&quot; % (self.type, self.area)</span><br><span class="line"></span><br><span class="line"># 定义屋子类</span><br><span class="line">class House:</span><br><span class="line">	# 同上</span><br><span class="line">    def __init__(self, address, area):</span><br><span class="line">        self.address &#x3D; address</span><br><span class="line">        self.area &#x3D; area</span><br><span class="line">        self.free_area &#x3D; area</span><br><span class="line"></span><br><span class="line">    def add_jiaju(self, jiaju):</span><br><span class="line">	    # 添加判断条件 确认是否有足够的空间</span><br><span class="line">        if self.free_area &gt;&#x3D; jiaju.area:</span><br><span class="line">            print(&quot;家具添加成功&quot;)</span><br><span class="line">            # 当添加一个家具的时候,需要在总面积减去家具自身面积,得到剩余面积</span><br><span class="line">            self.free_area -&#x3D; jiaju.area</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;添加失败&quot;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">       return &quot;房子的地址是%s.房子的面积是%s 房子的剩余面积是%s&quot; % (self.address, self.area, self.free_area)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  家具对象</span><br><span class="line">item1 &#x3D; JiaJu(&quot;双人床&quot;, 4)</span><br><span class="line">print(item1)</span><br><span class="line"># 房子对象</span><br><span class="line">home1 &#x3D; House(&quot;xxx&quot;, 200)</span><br><span class="line">print(home1)</span><br><span class="line"># 添加家具</span><br><span class="line">home1.add_jiaju(item1)</span><br><span class="line">print(home1)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--文件及目录删除添加修改</title>
    <url>/post/9a5bc4bd.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–文件及目录删除添加修改"><a href="#Python基础–文件及目录删除添加修改" class="headerlink" title="Python基础–文件及目录删除添加修改"></a>Python基础–文件及目录删除添加修改</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入os模块</span><br><span class="line">import os</span><br><span class="line"># 获取当前路径</span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br><span class="line"># 打印当前路径</span><br><span class="line">print(os.getcwd())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建test_dir文件夹,当文件夹已存在无法创建会报错</span><br><span class="line">os.mkdir(&quot;test_dir&quot;)</span><br><span class="line">os.mkdir(&quot;test_dir\tmp_dir&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 进入test_dir文件夹,进行对比演示</span><br><span class="line">print(os.getcwd())</span><br><span class="line">os.chdir(&quot;test_dir&quot;)</span><br><span class="line">print(os.getcwd())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除tmp_dir文件夹,然后进入test_dir文件夹进行确认</span><br><span class="line">os.rmdir(&quot;test_dir&#x2F;tmp_dir&quot;)</span><br><span class="line">os.chdir(&quot;test_dir&quot;)</span><br><span class="line">print(os.getcwd())</span><br><span class="line"></span><br><span class="line"># 列出当前文件夹所有的信息</span><br><span class="line">os.listdir(&quot;test_dir&quot;)</span><br></pre></td></tr></table></figure>
<p>== 切记:文件夹内如果有其他文件的时候是不能直接删除文件夹的,因为是非空文件夹,需要使用遍历或者进到文件夹内部进行删除 ==</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--步长</title>
    <url>/post/346020c6.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–步长"><a href="#Python基础–步长" class="headerlink" title="Python基础–步长"></a>Python基础–步长</h1><blockquote>
<p>步长格式    变量[开始索引:结束索引:长度]<br>步长计算公式   当前索引+ 步长= 下一个索引<br>步长同时也可以取成负数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 &#x3D; &quot;yesterday once more&quot;</span><br><span class="line">str2 &#x3D; str1[::-1]</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>步长为负数时,省略开头,对应的是最后一个结尾<br>步长为负数时,省略结尾,对应的是第一个元素</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str2 &#x3D; str1[10::-1]</span><br><span class="line">print(str2)</span><br><span class="line"></span><br><span class="line">str2 &#x3D; str1[:6:-1]</span><br><span class="line">print(str2)</span><br><span class="line"></span><br><span class="line">str2 &#x3D; str1[::-3]</span><br><span class="line">print(str2)</span><br><span class="line"></span><br><span class="line">str2 &#x3D; str1[5::-1]</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础-- 私有和继承</title>
    <url>/post/57771ef.html</url>
    <content><![CDATA[<h1 id="Python基础–-私有和继承"><a href="#Python基础–-私有和继承" class="headerlink" title="Python基础– 私有和继承"></a>Python基础– 私有和继承</h1><p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<blockquote>
<p>父类中的私有属性和方法是不会被子类所继承的<br>可以通过调用父类的公有方法,进而调用私有属性和私有方法<br>除了上面的方法外可以直接使用超类<code>super</code>进行调用,这个可以参考我的上一批文章P<code>ython基础--重写</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def __init__(self):</span><br><span class="line">	    # 定义公有属性</span><br><span class="line">        self.type &#x3D; &quot;猫科&quot;</span><br><span class="line">        # 定义私有属性</span><br><span class="line">        self.__color &#x3D; &quot;黄&quot;</span><br><span class="line"></span><br><span class="line">	# 定义私有方法</span><br><span class="line">    def __eat(self):</span><br><span class="line">        print(&quot;吃猫粮&quot;)</span><br><span class="line"></span><br><span class="line"># 创建子类</span><br><span class="line">class Tiger(Cat):</span><br><span class="line">    def do(self):</span><br><span class="line">        # 调用公有属性</span><br><span class="line">        print(self.type)</span><br><span class="line">        # 调用私有属性</span><br><span class="line">        print(self.__color)</span><br><span class="line"></span><br><span class="line"># 创建对象,并继承Cat父类属性</span><br><span class="line">ahuang &#x3D; Tiger()</span><br><span class="line"># 调用自己的方法,但是里面回去调用Cat类的私有属性,提示报错</span><br><span class="line">ahuang.do()</span><br><span class="line"># 直接调用私有方法同样是会报错的</span><br><span class="line">ahuang.__eat()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--私有属性</title>
    <url>/post/73e00582.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–私有属性"><a href="#Python基础–私有属性" class="headerlink" title="Python基础–私有属性"></a>Python基础–私有属性</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.__house &#x3D;&quot;张三&quot;</span><br><span class="line"># 这个房子是我有的,全世界只有我自己一个人有.表示自己独有的属性</span><br></pre></td></tr></table></figure>
<p>==在子类去调用父类的时候,有写父类的属性我们不希望被子类调用,仅仅希望父类自己使用,这个是旧会涉及到私有属性==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 私有属性: 只能在类的内部使用</span><br><span class="line">class Pig:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.baby_count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def birth(self):</span><br><span class="line">        self.baby_count +&#x3D; 1</span><br><span class="line">        print(&quot;呀,生了一个小猪仔&quot;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;小猪仔的数量是:%s&quot; % self.baby_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat1 &#x3D; Pig()</span><br><span class="line">cat1.birth()</span><br><span class="line">cat1.birth()</span><br><span class="line">print(cat1)</span><br><span class="line"># baby_cout 的数量被修改,但是我们不希望被修改,以免破坏业务逻辑</span><br><span class="line">cat1.baby_count &#x3D; 3</span><br><span class="line">print(cat1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解决方法: 引入私有属性</span><br><span class="line">#   在指定不想被外部修改的属性前面添加两个下划线</span><br><span class="line"># 私有属性: 只能在类的内部使用</span><br><span class="line">class Cat:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__baby_count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def birth(self):</span><br><span class="line">        self.__baby_count +&#x3D; 1</span><br><span class="line">        print(&quot;呀,生了一个小猪仔&quot;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;小猪仔的数量是:%s&quot; % self.__baby_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat1 &#x3D; Cat()</span><br><span class="line">cat1.birth()</span><br><span class="line">cat1.birth()</span><br><span class="line">print(cat1)</span><br><span class="line">cat1.baby_count &#x3D; 3</span><br><span class="line"># 我们对于cat1.baby_count 进行了赋值,但是最后打印出来类的返回值并没有按照外部修改的数值返回.证明该属性属于私有属性</span><br><span class="line">print(cat1.baby_count)</span><br><span class="line">print(cat1)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--私有方法</title>
    <url>/post/87cc270f.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–私有方法"><a href="#Python基础–私有方法" class="headerlink" title="Python基础–私有方法"></a>Python基础–私有方法</h1><p>==私有方法和私有属性是类似的,都是单词添加了下划线,但是私有方法的下划线只有前面有,后面是没有的”__name”类似于这个样子==</p>
<blockquote>
<p>切记: 私有方法只能在当前类的内部被调用,不能被外部调用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 私有方法</span><br><span class="line">class Cat:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__baby_count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def birth(self):</span><br><span class="line">        self.__baby_count +&#x3D; 1</span><br><span class="line">        print(&quot;呀,生了一个小猪仔&quot;)</span><br><span class="line">        self.leave()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;小猪仔的数量是:%s&quot; % self.__baby_count</span><br><span class="line"></span><br><span class="line">    def leave(self):</span><br><span class="line">        print(&quot;因为生了小猫咪,休息一段时间&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat1 &#x3D; Cat()</span><br><span class="line">cat1.birth()</span><br><span class="line">cat1.leave()</span><br><span class="line">print(cat1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在外部可以直接调用leave的方法,这个是只有生完小猫咪之后才能休息<br>我们需要让这个方法在这个类里面只能被其他方法调用,不能被外部调用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__baby_count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def birth(self):</span><br><span class="line">        self.__baby_count +&#x3D; 1</span><br><span class="line">        print(&quot;呀,生了一个小猪仔&quot;)</span><br><span class="line">        self.__leave()</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;小猪仔的数量是:%s&quot; % self.__baby_count</span><br><span class="line"></span><br><span class="line">    def __leave(self):</span><br><span class="line">        print(&quot;因为生了小猫咪,休息一段时间&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat1 &#x3D; Cat()</span><br><span class="line">cat1.birth()</span><br><span class="line">cat1.__leave()</span><br><span class="line">print(cat1)</span><br></pre></td></tr></table></figure>
<p>==还有一个神奇的方法,这里做个说明.既然我们不能直接调用,但是类本身是可以调用的呀,我们可以在包含私有方法的类里面也一个调用私有方法的属性,就能间接的去调用这个私有方法了==</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础-- 类属性</title>
    <url>/post/4b13a021.html</url>
    <content><![CDATA[<h1 id="Python基础–-类属性"><a href="#Python基础–-类属性" class="headerlink" title="Python基础– 类属性"></a>Python基础– 类属性</h1><blockquote>
<p> 类也是一个对象,在创建对象的时候会在自动创建<br> 实例对象  ==  类创建的对象<br>对象属性  ==  类创建的对象的属性<br> 类对象的作用</p>
<ul>
<li>创建实例对象</li>
<li>记录数据(类属性)和实现功能(类方法)</li>
</ul>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat :</span><br><span class="line">    type &#x3D; &quot;猫科&quot;        # 定义类属性</span><br><span class="line">    __color &#x3D; &#39;花&#39;       # 私有属性</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        print(name)</span><br><span class="line"></span><br><span class="line">print(Cat.type)</span><br><span class="line"># 直接修改类属性</span><br><span class="line">Cat.type &#x3D; &#39;小猫科&#39;</span><br><span class="line">print(Cat.type)</span><br><span class="line">Cat(&#39;xiaohua&#39;)</span><br><span class="line"># 直接调用私有属性是会直接报错,如下实例</span><br><span class="line">print(Cat.__color)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实例对象不能直接修改 类属性</span><br><span class="line"></span><br><span class="line">cat1 &#x3D; Cat(&quot;大白&quot;)</span><br><span class="line"># 直接修改cat1的type属性</span><br><span class="line">cat1.type &#x3D; &quot;cat1&quot;</span><br><span class="line"># 打印出来类属性</span><br><span class="line">print(Cat.type)</span><br><span class="line"># 打印cat1的属性</span><br><span class="line">print(cat1.type)</span><br><span class="line">print(Cat.type)</span><br></pre></td></tr></table></figure>
<p>==注意,虽然赋值成功了,但是并没有直接修改到类属性的值,只是对于cat1这个属性进行了再次赋值的操作<br>切记: 在类属性和实例属性同名的情况下,实例对象优先访问实例属性==</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--类方法和静态方法</title>
    <url>/post/3461e0b8.html</url>
    <content><![CDATA[<h1 id="Python基础–类方法和静态方法"><a href="#Python基础–类方法和静态方法" class="headerlink" title="Python基础–类方法和静态方法"></a>Python基础–类方法和静态方法</h1><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><ul>
<li>类对象所拥有的方法</li>
<li>需要使用<code>classmethod</code>来标识其为类方法</li>
<li>第一个参数必须是对象</li>
<li>一般以<code>cls</code>最为第一个参数</li>
</ul>
<a id="more"></a>
<blockquote>
<p>场景说明:<br>类方法和实例方法对比,类方法并不依赖实例对象<br>可以在没有实例对象的情况下,完成对类属性的处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    type &#x3D; &quot;狗&quot;</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def get_info(cls):</span><br><span class="line">        print(&quot;类型是: %s&quot;% cls.type)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用类方法,类对象&#x2F;实例对象都可以使用</span><br><span class="line">Dog.get_info()</span><br><span class="line"></span><br><span class="line"># 调用对象方法必须是需要有实例属性才能够被调用</span><br><span class="line">dog1 &#x3D; Dog()</span><br><span class="line">dog1.get_info()</span><br></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul>
<li>需要使用装饰器<code>staticmethod</code>进行修饰</li>
<li>默认情况下,静态方法既不传递类对象也不传递实例对象(形参没有<code>self/cls</code>)</li>
<li>静态方法可以通过实例对象和类对象去访问</li>
</ul>
<blockquote>
<p>场景说明:<br>当方法中既不需要使用实例对象,也不需要使用类对象的时候,可以定义静态方法<br>取消不需要的参数传递,有利于减少不必要的内存占用和性能消耗</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    # @staticmethod标识的方法为静态方法</span><br><span class="line">    # 静态方法既不传递实例对象,也不传递类对象(稍微节省性能)</span><br><span class="line">    def eat():</span><br><span class="line">        print(&quot;爱吃鱼&quot;)</span><br><span class="line"></span><br><span class="line">    def drink(self):</span><br><span class="line">        print(&quot;喝水&quot;)</span><br><span class="line"># 使用实例对象调用静态方法</span><br><span class="line">Cat.eat()</span><br><span class="line">cat1 &#x3D; Cat()</span><br><span class="line"># 使用类对象进行调用静态方法</span><br><span class="line">cat1.eat()</span><br></pre></td></tr></table></figure>
<h2 id="对象方法-类方法和静态方法的调用顺序"><a href="#对象方法-类方法和静态方法的调用顺序" class="headerlink" title="对象方法,类方法和静态方法的调用顺序"></a>对象方法,类方法和静态方法的调用顺序</h2><p>==类中同时定义了同样的对象方法,类方法和静态方法时,.会优先调用最后一个定义的方法==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;对象&quot;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def eat(cls):</span><br><span class="line">        print(&quot;类&quot;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    # @staticmethod标识的方法为静态方法</span><br><span class="line">    # 静态方法既不传递实例对象,也不传递类对象(稍微节省性能)</span><br><span class="line">    def eat():</span><br><span class="line">        print(&quot;静态&quot;)</span><br><span class="line"></span><br><span class="line"># 使用实例对象调用静态方法</span><br><span class="line">Cat.eat()</span><br><span class="line">cat1 &#x3D; Cat()</span><br><span class="line"># 使用类对象进行调用静态方法</span><br><span class="line">cat1.eat()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--组包和解包</title>
    <url>/post/b64db797.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–组包和解包"><a href="#Python基础–组包和解包" class="headerlink" title="Python基础–组包和解包"></a>Python基础–组包和解包</h1><h2 id="组包"><a href="#组包" class="headerlink" title="组包"></a>组包</h2><blockquote>
<p>组包: 自动操作,当<code>=</code>右边有多个数据的时候,会自动包装成为元组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 10, 20, 30</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><blockquote>
<p>变量数量 = 元素数量  会进行一一赋值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a, b, c &#x3D; 10, 20, 30</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c) </span><br></pre></td></tr></table></figure>
<h1 id="使用场景1-交换两个变量数值"><a href="#使用场景1-交换两个变量数值" class="headerlink" title="使用场景1;交换两个变量数值"></a>使用场景1;交换两个变量数值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进行变量值的相互交换,不用创建中间临时变量</span><br><span class="line"></span><br><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br><span class="line">a,b &#x3D; b,a</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h1 id="使用场景2-设置多个函数返回值"><a href="#使用场景2-设置多个函数返回值" class="headerlink" title="使用场景2:设置多个函数返回值"></a>使用场景2:设置多个函数返回值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义一个函数,返回多个任意数值</span><br><span class="line">def re_fun():</span><br><span class="line">    return 10, 20, 30</span><br><span class="line"></span><br><span class="line">a, b, c &#x3D; re_fun()</span><br><span class="line">print(re_fun())</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<h1 id="使用场景3-列表-字典-字符串同样使用"><a href="#使用场景3-列表-字典-字符串同样使用" class="headerlink" title="使用场景3: 列表,字典,字符串同样使用"></a>使用场景3: 列表,字典,字符串同样使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列表的拆包</span><br><span class="line">list1 &#x3D; [1,2]</span><br><span class="line">a, b &#x3D; list1</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"># 字典的拆包</span><br><span class="line">dict1 &#x3D; &#123;&quot;name&quot;: &quot;wa&quot;, &quot;age&quot;: 22&#125;</span><br><span class="line">for key1, vlaue1 in dict1.items():</span><br><span class="line">    print(key1)</span><br><span class="line">    print(vlaue1)</span><br><span class="line"># 字符串的拆包</span><br><span class="line">str1 &#x3D; &quot;once more &quot;</span><br><span class="line">for a in str1:</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--继承</title>
    <url>/post/57be43aa.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–继承"><a href="#Python基础–继承" class="headerlink" title="Python基础–继承"></a>Python基础–继承</h1><blockquote>
<p>继承相对来说比较简单,就是,一个类可以拥有指定类的所有方法<br>如果需要继承的话,类最少是需要2个,大于2个以上的话,就属于<code>多层继承</code></p>
</blockquote>
<p>==单继承的实例==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义Animal类</span><br><span class="line">class Animal:</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;要吃鱼&quot;)</span><br><span class="line"></span><br><span class="line"># 定义Cat类,父类是Animal</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&quot;喵喵喵喵喵喵&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 指定对象xiaohua,类是SmallYellowCat</span><br><span class="line">xiaohua &#x3D;Cat()</span><br><span class="line"># xiaohua可以调用父类的bark方法</span><br><span class="line">xiaohua.eat()</span><br></pre></td></tr></table></figure>
<p>==多层继承的实例==</p>
<blockquote>
<p>多层继承其实就是在单继承的基础上在添加了另外一个类进行继承</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义Animal类</span><br><span class="line">class Animal:</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;要吃鱼&quot;)</span><br><span class="line"></span><br><span class="line"># 定义Cat类,父类是Animal</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&quot;喵喵喵喵喵喵&quot;)</span><br><span class="line"></span><br><span class="line"># 定义SmallYellowCat类,父类是Cat</span><br><span class="line">class SmallYellowCat(Cat):</span><br><span class="line">    pass</span><br><span class="line">    # pass 是占位符,起到结束的含义</span><br><span class="line"></span><br><span class="line"># 指定对象xiaohua,类是SmallYellowCat</span><br><span class="line">xiaohua &#x3D; SmallYellowCat()</span><br><span class="line"># xiaohua可以调用父类的bark方法</span><br><span class="line">xiaohua.bark()</span><br><span class="line"># xiaohua也可以调用父类的父类eat方法</span><br><span class="line">xiaohua.eat()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--自定义异常</title>
    <url>/post/93168db1.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–自定义异常"><a href="#Python基础–自定义异常" class="headerlink" title="Python基础–自定义异常"></a>Python基础–自定义异常</h1><blockquote>
<p>当执行<code>try</code>内部代码的时候,易弹发生错误,会根据错误类型自动创建一个错误信息,并反馈<br><code>raise</code>用于引发异常,且异常必须是error和Exception的子类<br><code>as</code>是对于PhoneErr的别名</p>
</blockquote>
<!-- more -->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PhoneErr(BaseException):</span><br><span class="line"># 自定义的异常必须是BaseException的子类</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        num1 &#x3D; input(&quot;输入手机号:&quot;)</span><br><span class="line">        if not num1.isdecimal():</span><br><span class="line">            raise PhoneErr(&quot;不全部是数字&quot;)</span><br><span class="line">        elif len(num1) !&#x3D; 11:</span><br><span class="line">            raise PhoneErr(&quot;长度不够,手机号是11位数字&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;可以了&quot;)</span><br><span class="line">    except PhoneErr as e:</span><br><span class="line">		# 这个地方输出e是为了和小面的print做出对比,可以取消注释在单独对比下</span><br><span class="line">        # print(e)</span><br><span class="line">        print(&quot;报错为:%s&quot; % e)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--递归函数</title>
    <url>/post/b8e7ce3f.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–递归函数"><a href="#Python基础–递归函数" class="headerlink" title="Python基础–递归函数"></a>Python基础–递归函数</h1><p>==通俗一点来说在函数的内部,直接去调用其他函数的方式叫做函数的嵌套.但是,如果这个函数调用的是自身呢?这个样子的函数自身就属于递归函数==<br><code>Python对于递归函数的深度做了优化,最大只能执行1000次的计算,超过1000次就会直接报错,原因是递归函数非常消耗资源,而且容易出现栈溢出的现象</code></p>
<blockquote>
<p>人为调整递归深度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.setrecursionlimit(10000) </span><br><span class="line">#括号中的值为递归深度,调整后是1W.超过1W会出现这个报错</span><br><span class="line"></span><br><span class="line">RuntimeError: maximum recursion depth exceeded in comparison</span><br></pre></td></tr></table></figure>
<blockquote>
<p>经典实例:阶乘自身就能用递归函数来表达出来</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1! &#x3D; 1</span><br><span class="line">2! &#x3D; 2 * 1</span><br><span class="line">3! &#x3D; 3 * 2 *1</span><br><span class="line">...</span><br><span class="line">n! &#x3D; n * (n-1)*…… * 2 * 1 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上是简单直接说明了阶乘的表达,接下来至二级用函数来进行直接表达出来</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义一个函数,内部调用自己,如果是1 的换直接返回1</span><br><span class="line"># 如果是大于1的话,输出他的阶乘,最后打印出来</span><br><span class="line">def step_fun(num1):</span><br><span class="line">    if num1 &#x3D;&#x3D; 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return num1 * step_fun(num1 - 1)</span><br><span class="line"></span><br><span class="line"># step_fun(n) 里面的n 是自定义的参数,传参到函数内部,不知道的话,可以在之前的博文找下</span><br><span class="line">res &#x3D; step_fun(3)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--重写</title>
    <url>/post/91391f6c.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–重写"><a href="#Python基础–重写" class="headerlink" title="Python基础–重写"></a>Python基础–重写</h1><blockquote>
<p>当子类的方法与分类的方法同名的时候,这个是后就出现了<code>重写方法</code>的问题,<br>子类直接调用了自己的方法,不会在调用父类相同名字的方法</p>
</blockquote>
<p>==重写的实例==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&quot;我要吼两嗓子&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def bark(self):</span><br><span class="line">        # 重写: 在子类中定义和父类同样的方法</span><br><span class="line">        # 如果发生重写,只会调用当前类的方法,不会向父类查询方法</span><br><span class="line">        # 当前类--&gt;父类--&gt;在上级的父类--&gt;object-&gt;没有的话就会报错</span><br><span class="line">        print(&quot;喵喵喵喵喵喵&quot;)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">xiaohua &#x3D; Cat()</span><br><span class="line">xiaohua.bark()</span><br></pre></td></tr></table></figure>
<h1 id="指定调用被重写的方法"><a href="#指定调用被重写的方法" class="headerlink" title="指定调用被重写的方法"></a>指定调用被重写的方法</h1><blockquote>
<p>目前我们有三种方法来进行指定调用,从而避免被重写的问题</p>
<ul>
<li><code>父类名.方法(self)</code> 指定调用父类的方法,从而达到目前</li>
<li>引入超类</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&quot;嗷嗷嗷&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SmallCat(Cat):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&quot;汪汪汪&quot;)</span><br><span class="line"></span><br><span class="line">    def SeeMaster(self):</span><br><span class="line">        print(&quot;摇尾巴&quot;)</span><br><span class="line">        # self.bark() # 因为重写导致只能调用当前方法</span><br><span class="line"></span><br><span class="line">        # 需求:需要调用被重写的父类防范</span><br><span class="line"></span><br><span class="line">        # First 1</span><br><span class="line">        Cat.bark(self)</span><br><span class="line"></span><br><span class="line">        # First 2</span><br><span class="line">        # super(超类)</span><br><span class="line">        super(SmallCat, self).bark()</span><br><span class="line"></span><br><span class="line">        # 超类的简写</span><br><span class="line">        super().bark()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaohua &#x3D; SmallCat()</span><br><span class="line">xiaohua.SeeMaster()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--闭包</title>
    <url>/post/bf059315.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>在函数嵌套的前提下,内部函数使用了外部函数的变量,并且外部函数返回了内部函数.<code>使用外部函数变量的内部函数被称作闭包</code></p>
<h2 id="闭包的必须条件"><a href="#闭包的必须条件" class="headerlink" title="闭包的必须条件"></a>闭包的必须条件</h2><ul>
<li>在函数嵌套(函数里面再定义函数)的前提下</li>
<li>内部函数使用了外部函数的变量(还包括外部函数的参数)</li>
<li>外部函数返回了内部函数</li>
</ul>
<h2 id="闭包的代码"><a href="#闭包的代码" class="headerlink" title="闭包的代码"></a>闭包的代码</h2><p>这个是简单的代码实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def set_fun():</span><br><span class="line">    i &#x3D; 0</span><br><span class="line">    def call_fun():</span><br><span class="line">        nonlocal i  # 修改外层函数参数</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">        print(&quot;执行的次数:&quot;, i)</span><br><span class="line">    return call_fun</span><br><span class="line">    </span><br><span class="line">fun &#x3D; set_fun()</span><br><span class="line">fun()</span><br><span class="line">fun()</span><br><span class="line">fun()</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>
<p>当执行这个代码的时候你回发现<code>i</code>的值一直是在累加的,这个就是闭包最明显的作用了.把<code>函数加载到内存中</code>,随时等待被调用,闭包一般和装饰器一起用的,这里先说明下闭包,后面在详细说下装饰器.</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--面向对象</title>
    <url>/post/9f8b71d.html</url>
    <content><![CDATA[<h1 id="Python基础–面向对象"><a href="#Python基础–面向对象" class="headerlink" title="Python基础–面向对象"></a>Python基础–面向对象</h1><blockquote>
<p>面向过程: 按照业务逻辑从上到下,分析出来所有解决问题的所需步骤,然后逐步实现(详情可以自行Google或者度娘)</p>
</blockquote>
<blockquote>
<p>面向对象: ==将程序功能或者数据信息变成事物的行为和特征==把所需要实现的功能当做是一个整体的对象,进行拆分成各个方法从而实现各个功能</p>
</blockquote>
<a id="more"></a>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>某种具有相同特征的事物,统称为类<br>类似于动物界的犬科和猫科这种的分类(个人理解,勿喷)<br>类是总结事物抽象的特征</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>指的是具体的事物,比如说<code>隔壁老张家的大白狗</code>,特指的是单个事物<br>如果你说汽车,那就是类.<br>但是切记,汽车也分好多种,各个牌子的有属于单独的类,<code>只有特指单独的事物才能被称作对象</code></p>
<h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><ul>
<li>类就是被用作创造对象的,类里面的各种方法就是对象所有的信息特征</li>
<li>对象至少有一个对应的类,类可以没有对象</li>
</ul>
<h1 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h1><p>Python中定义类非常简单,只需要一个<code>class</code>就能搞定.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名:</span><br><span class="line">	方法列表</span><br></pre></td></tr></table></figure>
<p>==切记: 类需要有对应的命名规则  大驼峰命名法==</p>
<h1 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h1><p>方法和类是相辅相成的,有了方法,在对象调用类的时候就能执行对应的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名:</span><br><span class="line">	def 方法名(self):</span><br></pre></td></tr></table></figure>
<blockquote>
<p>举个实例,猫类,能够喝水和吃猫粮</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定类是Cat</span><br><span class="line">class Cat:</span><br><span class="line">	# 指定方法</span><br><span class="line">	def eat(self):</span><br><span class="line">		print(&quot;吃猫粮&quot;)</span><br><span class="line">	</span><br><span class="line">	def drink(self):</span><br><span class="line">		print(&quot;喝水&quot;)</span><br></pre></td></tr></table></figure>
<p>好了,我们已经创建了一个最最简单的类了,里面也有内置方法了,这个时候<code>对象</code>要登场了.</p>
<blockquote>
<p>创建一个自定义的对象<code>xiaohua</code>,并调用方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">	# 指定方法</span><br><span class="line">	def eat(self):</span><br><span class="line">		print(&quot;吃猫粮&quot;)</span><br><span class="line">	</span><br><span class="line">	def drink(self):</span><br><span class="line">		print(&quot;喝水&quot;)</span><br><span class="line"></span><br><span class="line"># 直接进行我们之前的复制操作.但是,是把对象复制给到了类</span><br><span class="line">xiaohua &#x3D; cat()</span><br><span class="line"># 调用方法eat,打印&#96;喝水&#96;</span><br><span class="line">xiaohua.eat()</span><br><span class="line"># 调用方法drink,打印出&#96;吃猫粮&#96;</span><br><span class="line">xiaohua.drink()</span><br></pre></td></tr></table></figure>
<p>好了,上面就是简单的介绍类. 方法. 和对象,这个概念稍微有些抽象,不容易理解,希望能多看看具体的概念和解释</p>
<blockquote>
<p>创建多个对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">	def eat(self):</span><br><span class="line">		print(&quot;吃猫粮&quot;)</span><br><span class="line">	</span><br><span class="line">	def drink(self):</span><br><span class="line">		print(&quot;喝水&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaohua &#x3D; Cat()</span><br><span class="line">xiaobai &#x3D; Cat()</span><br><span class="line">xiaohua.eat()</span><br><span class="line">xiaobai.eat()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--魔法方法(运算符重载)</title>
    <url>/post/c1dec957.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–魔法方法-运算符重载"><a href="#Python基础–魔法方法-运算符重载" class="headerlink" title="Python基础–魔法方法()运算符重载)"></a>Python基础–魔法方法()运算符重载)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;My name is %s&quot; % self.name)</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):       # __xx__(self):  魔法运算符(运算符重载),会在特定的情况下进行调用</span><br><span class="line">        # 对象创建完成之后会自动执行</span><br><span class="line">        # 场景要求: 在对象创建完成之后,就需要直接建初始化的操作,就可以直接是用__init__方法</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        print(&quot;My name is %s , age is %s&quot; % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat1 &#x3D; Cat(&quot;小黄&quot;, &quot;3&quot;)    # 创建对象 会把Cat()括号内部的内容进行传递类方法中的self函数中</span><br><span class="line"># cat1.hello()        # 调用指定的方法</span><br><span class="line">cat2 &#x3D; Cat(&quot;小白&quot;, &quot;2&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的def 中出现了一个函数==<code>__init__</code>==这个是初始值的魔法方法.这个是用来做初始化的魔法方法,在任何对象被定义之后就会直接调用这个魔法方法.赋予对象这个方法内部的所有属性.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">    def __str__(self):          # 进行对象打印的时候,会自动调用</span><br><span class="line">                                # 使用场景: 需要自定义指定对象的返回值</span><br><span class="line">        # str魔法方法必须有返回值,返回的内容会代替默认的对象打印内容</span><br><span class="line">        return &quot;My name is %s&quot; % self.name      # 返回必须指定为字符串类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat1 &#x3D; Cat(&quot;小白&quot;)</span><br><span class="line">print(cat1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面出现了一个==<code>__str__</code>==的魔法方法,是代替返回的,如果你需要指定返回值,需要在这个下面使用return返回指定的内容.</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--异常传递</title>
    <url>/post/cd498686.html</url>
    <content><![CDATA[<p><img src="/images/icon/python.jpg" alt="python"></p>
<a id="more"></a>
<h1 id="Python基础–异常传递"><a href="#Python基础–异常传递" class="headerlink" title="Python基础–异常传递"></a>Python基础–异常传递</h1><blockquote>
<p>try 嵌套是,如果内层的except不能捕获到异常,会把异常传递给外层的except<br>如果还无法捕获,就会继续传递,知道无法传达报错</p>
</blockquote>
<h2 id="try的嵌套-传递异常"><a href="#try的嵌套-传递异常" class="headerlink" title="try的嵌套,传递异常"></a>try的嵌套,传递异常</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&quot;123&quot;)</span><br><span class="line">    try:</span><br><span class="line">        print(a)</span><br><span class="line">    except FileExistsError:</span><br><span class="line">        print(&quot;文件存在报错&quot;)</span><br><span class="line">except BaseException:</span><br><span class="line">    print(&quot;程序内部出现异常&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="try嵌套但是最外层异常"><a href="#try嵌套但是最外层异常" class="headerlink" title="try嵌套但是最外层异常"></a>try嵌套但是最外层异常</h2><blockquote>
<p>这个实例是直接报错,没有后续执行被except捕获直接打印</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(a)</span><br><span class="line">    try:</span><br><span class="line">        print(&quot;a&quot;)</span><br><span class="line">    except FileExistsError:</span><br><span class="line">        print(&quot;文件存在报错&quot;)</span><br><span class="line">except BaseException:</span><br><span class="line">    print(&quot;程序内部出现异常&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>k8s-办公内网与k8s内网互通</title>
    <url>/post/40ccad37.html</url>
    <content><![CDATA[<h1 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h1><p>k8s集群的pod网段为179.10.0.0/16，svc的网段为179.20.0.0/16<br>办公网为18.16.0.0/16<br>k8s nat节点ip为18.16.200.149/32 宿主机ip段为18.16.200.0/24</p>
<h1 id="办公网于k8s内网互通"><a href="#办公网于k8s内网互通" class="headerlink" title="办公网于k8s内网互通"></a>办公网于k8s内网互通</h1><p>目前线下环境迁移到k8s集群，运行在k8s内的微服务应用注册到nacos，注册的为本地办公网ip+port，但开发在本地办公电脑上启动服务，注册到nacos，注册信息是办公网络的IP与端口，因为办公网络与k8s集群内部网络相对隔离，导致服务之间调用异常。</p>
<h1 id="添加路由中转机"><a href="#添加路由中转机" class="headerlink" title="添加路由中转机"></a>添加路由中转机</h1><p>选定k8s内的一台node节点专门作为路由,配置低一点没有关系, 禁止调度就行, <code>test-worker-4</code>作为本次的NAT机器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@test-master-1 ~]# kubectl get nodes </span><br><span class="line">NAME            STATUS                     ROLES                AGE    VERSION</span><br><span class="line">test-master-1   Ready                      etcd,master,worker   108d   v1.18.8</span><br><span class="line">test-master-2   Ready                      etcd,master,worker   108d   v1.18.8</span><br><span class="line">test-master-3   Ready                      etcd,master,worker   108d   v1.18.8</span><br><span class="line">test-worker-1   Ready                      worker               73d    v1.18.8</span><br><span class="line">test-worker-2   Ready                      worker               73d    v1.18.8</span><br><span class="line">test-worker-3   Ready                      worker               73d    v1.18.8</span><br><span class="line">test-worker-4   Ready,SchedulingDisabled   worker               11d    v1.18.8</span><br></pre></td></tr></table></figure>
<h1 id="开启nat节点的路由转发功能"><a href="#开启nat节点的路由转发功能" class="headerlink" title="开启nat节点的路由转发功能"></a>开启nat节点的路由转发功能</h1><p>test-worker-4节点执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;net.ipv4.ip_forward &#x3D; 1&quot;  &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<h1 id="设置转发规则"><a href="#设置转发规则" class="headerlink" title="设置转发规则"></a>设置转发规则</h1><p>test-worker-4节点执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 18.16.0.0&#x2F;16 -d 179.20.0.0&#x2F;16 -j MASQUERADE</span><br><span class="line">iptables -t nat -A POSTROUTING -s 18.16.0.0&#x2F;16 -d 179.10.0.0&#x2F;16 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<h1 id="本地网络添加静态路由"><a href="#本地网络添加静态路由" class="headerlink" title="本地网络添加静态路由"></a>本地网络添加静态路由</h1><p>本地的网络尽量是私网ip,在出口的路由骑上添加静态路由, 是在不知道的话就问下网络的同事</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip route 179.20.0.0 255.255.0.0 18.16.200.149</span><br><span class="line">ip route 179.10.0.0 255.255.0.0 18.16.200.149</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
        <category>linux</category>
        <category>Kubernetes</category>
        <category>容器</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>Kubernetes</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>杂记--mooc网站top10</title>
    <url>/post/c83a0c52.html</url>
    <content><![CDATA[<p>　1、MOOC中国 <a href="http://www.mooc.cn/">http://www.mooc.cn</a><br>　　网站介绍：MOOC中国（MOOC.CN）致力于向国内小伙伴分享最好的慕课。在慕课中国的在线教育资源比较丰富，学习比较自由，网站对于用户群体开放程度很高。目前在线的冷门课程较多，随着不断的发展，未来的课程更加趋于受众广泛化。<br>　　主要特点：有搜索功能，页面设计友好，使用起来也比较方便。<br>　　推荐指数：4颗星<br>2、慕课网 <a href="http://www.imooc.com/">http://www.imooc.com</a><br>　　网站简介：属于北京慕课科技中心，是一家从事互联网免费教学的网络教育公司。秉承“开拓、创新、公平、分享”的精神，将互联网特性全面的应用在教育领域，致力于为教育机构及求学者打造一站式互动在线教育品牌。<br>　　主要特点：科技类慕课内容，网站使用起来非常方便，西贝体验过两天的编程课程，非常有意思，学到东西还是完全有可能的。<br>　　推荐指数：5颗星</p>
<a id="more"></a>
<p>3、爱课程 <a href="http://www.icourses.cn/">http://www.icourses.cn</a><br>　　网站介绍：“爱课程”网是教育部、财政部“十二五”期间启动实施的“高等学校本科教学质量与教学改革工程”支持建设的高等教育课程资源共享平台。网站集中展示了“中国大学视频公开课”和“中国大学资源共享课”，并对课程资源进行运行、更新、维护和管理。网站利用现代信息技术和网络技术， 面向高校师生和社会大众，提供优质教育资源共享和个性化教学资源服务，具有资源浏览、搜索、重组、评价、课程包的导入导出、发布、互动参与和“教”“学”兼备等功能。<br>　　网站汇集了很多高校教育的开放资源，可以搜索到自己喜欢的课程。<br>　　主要特点：网站资源相对丰富，涵盖面广，汇聚的大学数量较大。<br>　　推荐指数：3.5颗星<br>4、中国大学Mooc <a href="http://www.icourse163.org/">http://www.icourse163.org</a><br>　　网站介绍：每门课程有老师设置的考核标准，当学生的最终成绩达到老师的考核分数标准，即可免费获取由学校发出主讲老师签署的合格/优秀证书（电子版），也可付费申请纸质版认证证书。获取证书，意味着学生达到了学习要求，对这门课内容的理解和掌握达到了对应大学的要求。他（她）也可以骄傲地将通过了这门课的事实写在其简历中。<br>　　根据不同时间的开课情况，我们汇集热门课程形成百课全书，解析课程、发现课程亮点并按期推出，更好地诠释MOOC课程以便帮助你选择到最需要的课程内容。<br>　　主要特点：个性化设计比较明显，由网易发起，资源相对丰富<br>　　推荐指数：4颗星<br>5、好大学在线 <a href="http://www.cnmooc.org/">http://www.cnmooc.org</a><br>　　网站介绍： 中国高水平大学慕课联盟的官方网站， 联盟是部分中国高水平大学间自愿组建的开放式合作教育平台， 为公益性、开放式、非官方、非法人的合作组织。旨在通过交流、 研讨、协商与协作等活动，建设具有中国特色的、高水平的大规模在线开放课程平台， 向成员单位内部和社会提供高质量的慕课课程。<br>　　主要特点：起点较高，资源丰富程度不错<br>　　推荐指数：4颗星<br>6、学堂在线 <a href="http://www.xuetangx.com/">http://www.xuetangx.com</a><br>　　学堂在线是免费公开的MOOC（大规模开放在线课程）平台，是教育部在线教育研究中心的研究交流和成果应用平台，致力于通过来自国内外一流名校开设的免费网络学习课程，为公众提供系统的高等教育，让每一个中国人都有机会享受优质教育资源。通过和清华大学在线教育研究中心、以及国内外知名大学的紧密合作，学堂在线将不断增加课程的种类和丰富程度。<br>　　主要特点：内容丰富，资源涵盖面广，大学数量不错<br>　　推荐指数：4.5颗星<br>7、天天象上 <a href="http://www.daydays.com/">http://www.daydays.com</a><br>　　网站介绍：天天象上属于优堂教育科技，是一个专注于K12领域的C+2C在线教育平台。与全国百强名校万位名师独家签约，助力名师在线创建完整教学体系，通过“微课、资料、习题、检测、互动”等教学方法，提供一流的教学内容和服务。既为学生搭建了一个可靠高效的优质平台，又满足了广大一线教师提升学术水平、体现自我价值的迫切需求。<br>　　主要特点：青少年课程，比较有意思，适合青少年学习<br>　　推荐指数：4颗星<br>8、咪咕学堂 <a href="http://www.miguxue.com/">http://www.miguxue.com</a><br>　　咪咕数字手机（WAP、客户端）和移动电子书为主要形态，基于用户对各类题材内容的阅读需求，与具备内容出版或发行资质的机构合作，整合各类阅读内容，打造全新的内容发行渠道，推出和阅读、和听书 、和新闻、咪咕学堂等品牌产品，让用户享受时尚、健康、环保、便捷的随身阅读新体验。“咪咕学堂”是由咪咕数字传媒有限公司倾情打造的平台型即时互动学习应用，提供一站式贴心学习服务。咪咕学堂”面向中小学、职业、出国留学和幼儿教育类学习群体提供海量优质学习资源，包括直播课程、视频课程；整合学习兴趣圈等互动能力，创新“练学测疑”闭环型微学习模式。<br>　　主要特点：内容涵盖面较广，多种上课终端，比较方便<br>　　推荐指数：3.5颗星<br>9、万门大学 <a href="http://www.wanmen.org/">http://www.wanmen.org</a><br>　　万门大学, 中国第一所网络大学, 由童哲校长创办, 创立于2012年, 致力于降低教育的门槛, 力图通过为社会提供高品质视频课程, 让稀缺的教育资源唾手可得, 让高昂的学习成本不再成为学习的门槛。网站秉承着“知识创造乐趣, 你是你的大学”的创立宗旨, 持续推出新课, 为教育助力, 让更多人通过万门这个网络教育平台获得更加优质的学习体验。<br>　　主要特点：内容涵盖面较广，多种资源联合发出，创立时间较长。<br>　　推荐指数：4颗星<br>10、顶你学堂 <a href="http://www.topu.com/">http://www.topu.com</a><br>　　顶你学堂(TopU.com)是过来人于2012年10月推出的中国首个正式商业运营并且拥有完全自主知识产权的大规模开放在线教育MOOC平台，立足促进教育公平、探索教育创新以及帮助青年人就业。先后与清华、北大、中科大、香港大学、台湾大学等一流大学合作，并且与100多所高校合作推行MOOC学分课，把一流的中文课程内容带给全世界。同时，也将世界一流大学的在线课程带到中国。课程涵盖了计算科学、历史人文、创业创新、就业辅导、力学、经济、材料、数学等十余大门类，用户覆盖所有985与211高校，力争成为14亿中国人的在线大学。<br>　　主要特点：学校跨度大，涵盖面不错，网站体验也很棒。<br>　　推荐指数：4.5颗星<br>　　注解：<br>　　1、一共五颗星，按照不同的维度评级；<br>　　2、Massive Open Online Course的缩写，即大规模的在线开放课程或者大型开放式网络课程；</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础--线程</title>
    <url>/post/539a9e0b.html</url>
    <content><![CDATA[<h1 id="Python基础–线程"><a href="#Python基础–线程" class="headerlink" title="Python基础–线程"></a>Python基础–线程</h1><h2 id="线程的理解"><a href="#线程的理解" class="headerlink" title="线程的理解"></a>线程的理解</h2><ul>
<li>   线程是cpu调度(执行)的单位</li>
<li>程序会自动启用一个主线程</li>
<li>子线程是人为创建<blockquote>
<p>线程是在进程的基础上进行运行的,可以说,没有进程就不会产生线程. ==在当前进程下的所有线程下,变量是被共享的==<br>线程的执行方式稍微有一点奇怪,在人们看来可以说是同时执行的,但是其实不是的. 线程是有CPU分配资源,随机进行运行的.每个线程都会运行一小段时间,然后运行其他线程.</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="线程的作用"><a href="#线程的作用" class="headerlink" title="线程的作用"></a>线程的作用</h2><ul>
<li>   完成多任务,提高cpu效率</li>
<li>线程的执行是需要CPU的调度完成<h2 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导包 import threading</span><br><span class="line">加入任务 threading.Thread(target&#x3D;任务名)</span><br><span class="line">开启 xxx.start()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time		 # 导入时间包</span><br><span class="line">import threading # 导入线程包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">	&quot;&quot;&quot;执行跳舞&quot;&quot;&quot;</span><br><span class="line">	while True:</span><br><span class="line">		print(&quot;跳舞&quot;)</span><br><span class="line">		time.sleep(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def song():</span><br><span class="line">	&quot;&quot;&quot;执行唱歌&quot;&quot;&quot;</span><br><span class="line">	while True:</span><br><span class="line">		print(&quot;唱歌&quot;)</span><br><span class="line">		time.sleep(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">	&quot;&quot;&quot;多线程开启&quot;&quot;&quot;</span><br><span class="line">	# threading.Thread(target&#x3D;任务名)</span><br><span class="line">	thread_song &#x3D; threading.Thread(target&#x3D;song)</span><br><span class="line">	thread_dance &#x3D; threading.Thread(target&#x3D;dance)</span><br><span class="line">	# 开启</span><br><span class="line">	thread_song.start()</span><br><span class="line">	thread_dance.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="多线程传参两种方式"><a href="#多线程传参两种方式" class="headerlink" title="多线程传参两种方式"></a>多线程传参两种方式</h2></li>
<li>args使用元组<ul>
<li>表示已元组的方式传参</li>
<li>   传的元素位置需要与函数的形参位置一一对应<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">	&quot;&quot;&quot;执行跳舞&quot;&quot;&quot;</span><br><span class="line">	while True:</span><br><span class="line">		print(&quot;跳舞&quot;)</span><br><span class="line">		time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def song(name,age):</span><br><span class="line">	&quot;&quot;&quot;执行唱歌&quot;&quot;&quot;</span><br><span class="line">	while True:</span><br><span class="line">		print(&quot;唱歌&quot;,name,age)</span><br><span class="line">		time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">	&quot;&quot;&quot;入口函数&quot;&quot;&quot;</span><br><span class="line">	# 一边唱歌一边跳舞</span><br><span class="line">	thread_song &#x3D; threading.Thread(target&#x3D;song,args&#x3D;(&quot;小白&quot;,18))</span><br><span class="line">	</span><br><span class="line">	thread_song.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>kwargs使用字典<ul>
<li>   表示以字典的形式传参</li>
<li>   因为是无序的,所有key和参数对应,vlaue就是参数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance(name,age):</span><br><span class="line">	&quot;&quot;&quot;执行跳舞&quot;&quot;&quot;</span><br><span class="line">	while True:</span><br><span class="line">		print(&quot;跳舞&quot;)</span><br><span class="line">		time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def song(name,age):</span><br><span class="line">	&quot;&quot;&quot;执行唱歌&quot;&quot;&quot;</span><br><span class="line">	while True:</span><br><span class="line">		print(&quot;唱歌&quot;,name,age)</span><br><span class="line">		time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">	&quot;&quot;&quot;入口函数&quot;&quot;&quot;</span><br><span class="line">	# 一边唱歌一边跳舞</span><br><span class="line">	thread_song &#x3D; threading.Thread(target&#x3D;song,args&#x3D;(&quot;小白&quot;,18))</span><br><span class="line">	thread_song.start()</span><br><span class="line">	</span><br><span class="line">	thread_dance &#x3D; threading.Thread(target&#x3D;dance,kwargs&#x3D;&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;小花&quot;&#125;)</span><br><span class="line">	thread_dance.start()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="多线程的注意点"><a href="#多线程的注意点" class="headerlink" title="多线程的注意点"></a>多线程的注意点</h2></li>
</ul>
</li>
<li>   主线程会等待子线程结束而结束</li>
<li>   守护线程,只要主线程结束守护线程就结束</li>
<li>   线程执行是无序的</li>
<li>   线程之间共享全局变量(共享就会有资源竞争的问题)</li>
<li> 资源竞争解决方案<ul>
<li>同步join<ul>
<li>   join函数是将多个线程或者进程按照单线程的方式执行,执行了一个线程之后再去执行另外一个线程</li>
<li>   缺点运算速度比较慢</li>
</ul>
</li>
<li>   互斥锁</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习--机器学习简介</title>
    <url>/post/d74caf85.html</url>
    <content><![CDATA[<p><img src="/images/machine/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0logo.jpg" alt="机器学习"></p>
<a id="more"></a>

<h1 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h1><p>机器学习是从数据中自动分析获得模型, 并利用模型对位置数据进行预测.</p>
<h1 id="机器学习的工作流程"><a href="#机器学习的工作流程" class="headerlink" title="机器学习的工作流程"></a>机器学习的工作流程</h1><p><img src="/images/machine/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="机器学习流程"></p>
<!-- more -->

<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><ul>
<li>业务数据</li>
<li>爬虫数据</li>
<li>第三方<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2></li>
</ul>
<p><img src="/images/machine/%E6%95%B0%E6%8D%AE%E9%9B%86.png" alt="数据集"><br>在数据集中一般：</p>
<ul>
<li>一行数据我们称为一个<code>样本</code></li>
<li>一列数据我们成为一个<code>特征</code><br>有些数据有目标值（标签值），有些数据没有目标值（如上表中，电影类型就是这个数据集的目标值）</li>
</ul>
<p>数据类型构成：</p>
<ul>
<li>数据类型一：特征值+目标值（目标值是连续的和离散的）</li>
<li>数据类型二：只有特征值，没有目标值</li>
</ul>
<h2 id="数据的基本处理"><a href="#数据的基本处理" class="headerlink" title="数据的基本处理"></a>数据的基本处理</h2><ul>
<li>数据清洗</li>
<li>数据过滤<h3 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h3>机器学习一般的数据集会划分为两个部分：</li>
<li>训练数据：用于训练，构建模型</li>
<li>测试数据：在模型检验时使用，用于评估模型是否有效</li>
</ul>
<p>划分比例：</p>
<ul>
<li>训练集：70% 80% 75%</li>
<li>测试集：30% 20% 25%</li>
</ul>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>将数据转换成数学公式能够表达的过程, 复杂的说就是利用数据领域的知识,创建能让机器学习算法性能最大化的过程.<br><strong>机器学习领域的大神Andrew Ng(吴恩达)老师说“Coming up with features is difficult, time-consuming, requires expert knowledge. “Applied machine learning” is basically feature engineering. ”</strong></p>
<h3 id="特征的分类"><a href="#特征的分类" class="headerlink" title="特征的分类"></a>特征的分类</h3><ul>
<li>原始特征和高级特征<ul>
<li>原始特征: 不需要或者极少的人工干预和处理. 比如文本特征的词向量特征,图片中的像素点</li>
<li>高级特征: 结合业务逻辑或者模型,规则之类的复杂处理得到的特征,比如明星综合实力,学生综合素质.</li>
</ul>
</li>
<li>非实时特征和实时特征<ul>
<li>非实时特征: 指的是变化频率比较少的特征,比如,商品单价</li>
<li>实时特征: 频繁更新的特征,比如步速,比如股票走势</li>
</ul>
</li>
<li>离散值特征和连续值特征<ul>
<li>离散值特征: 可能是固定的离散值,比如一周有七天.或者布尔特征,指的是非黑即白.</li>
<li>连续值特征: 是有理数的特征,取值个数不定,比如距离特征,特征取值是[0,正无穷)<h3 id="特征工程包含的内容"><a href="#特征工程包含的内容" class="headerlink" title="特征工程包含的内容"></a>特征工程包含的内容</h3><h4 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h4>特征提取：将任意数据（如文本或图像）转换为可用于机器学习的数字特征<br><img src="/images/machine/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96.png" alt="特征提取"></li>
</ul>
</li>
</ul>
<h4 id="特征预处理"><a href="#特征预处理" class="headerlink" title="特征预处理"></a>特征预处理</h4><p>特征预处理：通过一些转换函数将特征数据转换成更加适合算法模型的特征数据过程<br><img src="/images/machine/%E7%89%B9%E5%BE%81%E9%A2%84%E5%A4%84%E7%90%86.png" alt="特征预处理"></p>
<h4 id="特征降维"><a href="#特征降维" class="headerlink" title="特征降维"></a>特征降维</h4><p>特征降维：指在某些限定条件下，降低随机变量(特征)个数，得到一组“不相关”主变量的过程<br><img src="/images/machine/%E7%89%B9%E5%BE%81%E9%99%8D%E7%BB%B4.png" alt="特征降维"></p>
<h2 id="机器学习-模型训练"><a href="#机器学习-模型训练" class="headerlink" title="机器学习(模型训练)"></a>机器学习(模型训练)</h2><p>使用训练集进行训练</p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>输入数据是由输入特征值和目标值所组成。</p>
<ul>
<li>函数的输出可以是一个连续的值(称为回归），</li>
<li>或是输出是有限个离散值（称作分类）。<h4 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h4>例如：预测房价，根据样本集拟合出一条连续曲线。<br><img src="/images/machine/%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B.png" alt="房价预测"><h4 id="分类学习"><a href="#分类学习" class="headerlink" title="分类学习"></a>分类学习</h4>例如：根据肿瘤特征判断良性还是恶性，得到的是结果是“良性”或者“恶性”，是离散的。<br><img src="/images/machine/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98.png" alt="肿瘤判断"><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3>输入数据是由输入特征值组成。<br>输入数据没有被标记，也没有确定的结果。样本数据类别未知，需要根据样本间的相似性对样本集进行分类（聚类，clustering）试图使类内差距最小化，类间差距最大化。<br><img src="/images/machine/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png" alt="无监督学习"></li>
</ul>
<h3 id="有无监督学习的对比"><a href="#有无监督学习的对比" class="headerlink" title="有无监督学习的对比"></a>有无监督学习的对比</h3><p><img src="/images/machine/%E6%9C%89%E7%9B%91%E7%9D%A3%E6%97%A0%E7%9B%91%E7%9D%A3%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt="有无监督学习的对比"></p>
<h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p><img src="/images/machine/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E8%AE%AD%E7%BB%83%E6%96%B9%E5%BC%8F.png" alt="监督学习"><br><img src="/images/machine/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E8%AE%AD%E7%BB%83%E6%96%B9%E5%BC%8F.png" alt="半监督学习"></p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习：实质是，make decisions 问题，即自动进行决策，并且可以做连续决策。<br>小孩想要走路，但在这之前，他需要先站起来，站起来之后还要保持平衡，接下来还要先迈出一条腿，是左腿还是右腿，迈出一步后还要迈出下一步。</p>
<p>小孩就是 agent，他试图通过采取行动（即行走）来操纵环境（行走的表面），并且从一个状态转变到另一个状态（即他走的每一步），当他完成任务的子任务（即走了几步）时，孩子得到奖励（给巧克力吃），并且当他不能走路时，就不会给巧克力。</p>
<p>主要包含四个元素：agent，环境状态，行动，奖励.</p>
<p><img src="/images/machine/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.png" alt="强化学习"></p>
<h3 id="监督学习和强化学习的对比"><a href="#监督学习和强化学习的对比" class="headerlink" title="监督学习和强化学习的对比"></a>监督学习和强化学习的对比</h3><table>
<thead>
<tr>
<th align="left">`</th>
<th align="right">监督学习</th>
<th align="center">强化学习</th>
</tr>
</thead>
<tbody><tr>
<td align="left">反馈映射</td>
<td align="right">输入到输出的一个映射，监督式学习输出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出。</td>
<td align="center">输入到输出的一个映射，强化学习输出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。</td>
</tr>
<tr>
<td align="left">反馈时间</td>
<td align="right">做了比较坏的选择会立刻反馈给算法。</td>
<td align="center">结果反馈有延时，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏。</td>
</tr>
<tr>
<td align="left">输入特征</td>
<td align="right">输入是独立同分布的。</td>
<td align="center">面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入。</td>
</tr>
<tr>
<td align="left">行为模式</td>
<td align="right">不考虑行为间的平衡，只是开发（exploitation）</td>
<td align="center">一个 agent 可以在探索和开发（exploration and exploitation）之间做权衡，并且选择一个最大的回报。</td>
</tr>
</tbody></table>
<p>如下图, 大家可以看下<code>AlphaGo</code>的进化史, 想要详细了解的话可以查看  <a href="/images/machine/alpha_zero.gif">Alphago进化史 漫画告诉你Zero为什么这么牛</a></p>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>利用测试集机型评估</p>
<ul>
<li>验证模型是否正确</li>
<li>使用测试数据预测结果和正式结果进行比较<h3 id="分类模型评估"><a href="#分类模型评估" class="headerlink" title="分类模型评估"></a>分类模型评估</h3></li>
<li>准确率<ul>
<li>预测正确的数占样本总数的比例。</li>
</ul>
</li>
<li>精确率<ul>
<li>正确预测为正占全部预测为正的比例</li>
</ul>
</li>
<li>召回率<ul>
<li>正确预测为正占全部正样本的比例</li>
</ul>
</li>
<li>F1-score<ul>
<li>主要用于评估模型的稳健性</li>
</ul>
</li>
<li>AUC指标<ul>
<li>主要用于评估样本不均衡的情况</li>
</ul>
</li>
</ul>
<h3 id="回归模型评估"><a href="#回归模型评估" class="headerlink" title="回归模型评估"></a>回归模型评估</h3><p><img src="/images/machine/alpha_zero.gif" alt="回归模型评估"></p>
<ul>
<li>均方根误差（Root Mean Squared Error，RMSE）<br>RMSE是一个衡量回归模型误差率的常用公式。 然而，它仅能比较误差是相同单位的模型。</li>
</ul>
<p><img src="/images/machine/%E5%9D%87%E6%96%B9%E6%A0%B9%E8%AF%AF%E5%B7%AE.png" alt="均方根误差"></p>
<ul>
<li>相对平方误差（Relative Squared Error，RSE）<br>与RMSE不同，RSE可以比较误差是不同单位的模型。</li>
</ul>
<p><img src="/images/machine/%E7%9B%B8%E5%AF%B9%E5%B9%B3%E6%96%B9%E8%AF%AF%E5%B7%AE.png" alt="相对平方误差"></p>
<ul>
<li><p>平均绝对误差（Mean Absolute Error，MAE)<br>MAE与原始数据单位相同， 它仅能比较误差是相同单位的模型。量级近似与RMSE，但是误差值相对小一些。<br><img src="/images/machine/%E5%B9%B3%E5%9D%87%E7%BB%9D%E5%AF%B9%E8%AF%AF%E5%B7%AE.png" alt="平均绝对误差"></p>
</li>
<li><p>相对绝对误差（Relative Absolute Error，RAE)<br>与RSE不同，RAE可以比较误差是不同单位的模型。</p>
</li>
</ul>
<p><img src="/images/machine/%E7%9B%B8%E5%AF%B9%E7%BB%9D%E5%AF%B9%E8%AF%AF%E5%B7%AE.png" alt="相对绝对误差"></p>
<ul>
<li>决定系数 (Coefficient of Determination)<br>决定系数 (R2)回归模型汇总了回归模型的解释度，由平方和术语计算而得。</li>
</ul>
<p><img src="/images/machine/%E5%86%B3%E5%AE%9A%E7%B3%BB%E6%95%B0.png" alt="决定系数"><br>R2描述了回归模型所解释的因变量方差在总方差中的比例。R2很大，即自变量和因变量之间存在线性关系，如果回归模型是“完美的”，SSE为零，则R2为1。R2小，则自变量和因变量之间存在线性关系的证据不令人信服。如果回归模型完全失败，SSE等于SST，没有方差可被回归解释，则R2为零。</p>
<h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><p>模型评估用于评价训练好的的模型的表现效果，其表现效果大致可以分为两类：过拟合、欠拟合。</p>
<p>在训练过程中，你可能会遇到如下问题：</p>
<p><em>训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？</em><br>当算法在某个数据集当中出现这种情况，可能就出现了<code>拟合问题</code>。</p>
<h4 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h4><p>因为机器学习到的天鹅特征太少了，导致区分标准太粗糙，不能准确识别出天鹅。<br><img src="/images/machine/%E6%AC%A0%E6%8B%9F%E5%90%88.png" alt="欠拟合"></p>
<h4 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h4><p>机器已经基本能区别天鹅和其他动物了。然后，很不巧已有的天鹅图片全是白天鹅的，于是机器经过学习后，会认为天鹅的羽毛都是白的，以后看到羽毛是黑的天鹅就会认为那不是天鹅。</p>
<p><code>过拟合</code>（over-fitting）：所建的机器学习模型或者是深度学习模型在训练样本中表现得过于优越，导致在验证数据集以及测试数据集中表现不佳。<br><img src="/images/machine/%E6%AC%A0%E6%8B%9F%E5%90%88.png" alt="过拟合"></p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
</search>
